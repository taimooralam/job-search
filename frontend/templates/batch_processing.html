{% extends "base.html" %}

{% block content %}
<div class="space-y-4">
    <!-- Page Header -->
    <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
            <a href="/" class="btn btn-ghost btn-sm">
                <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                </svg>
                Back
            </a>
            <div>
                <h1 class="text-xl font-bold theme-text-primary">Batch Processing</h1>
                <p class="text-sm theme-text-secondary">Process multiple jobs at once</p>
            </div>
        </div>
        <div class="flex items-center gap-4">
            <!-- LinkedIn Multi-Import Dropdown -->
            {% include 'components/linkedin_import.html' %}
            <!-- Keyboard Shortcuts Help -->
            <button onclick="toggleKeyboardShortcutsHelp()"
                    class="btn btn-ghost btn-sm flex items-center gap-1"
                    title="Keyboard Shortcuts">
                <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707"/>
                </svg>
                <span class="hidden sm:inline">Shortcuts</span>
            </button>
            <span id="batch-job-count" class="text-sm theme-text-secondary">
                <span class="font-semibold">0</span> jobs in queue
            </span>
        </div>
    </div>

    <!-- Progress Overview Panel (hidden by default, shown when batch operations are running) -->
    <div id="batch-progress-panel" class="panel p-4 hidden">
        <div class="flex items-center justify-between mb-3">
            <div class="flex items-center gap-3">
                <svg class="h-5 w-5 text-indigo-500 animate-spin" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <div>
                    <h3 class="font-semibold theme-text-primary">Batch Operation in Progress</h3>
                    <p id="batch-progress-status" class="text-sm theme-text-secondary">
                        <span id="batch-progress-completed">0</span>/<span id="batch-progress-total">0</span> operations complete
                    </p>
                </div>
            </div>
            <button onclick="cancelBatchOperation()" class="btn btn-ghost btn-sm text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20">
                Cancel
            </button>
        </div>
        <!-- Progress Bar -->
        <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
            <div id="batch-progress-bar" class="bg-indigo-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <!-- Individual Job Progress -->
        <div id="batch-progress-details" class="mt-3 max-h-32 overflow-y-auto space-y-1">
            <!-- Populated dynamically -->
        </div>
    </div>

    <!-- Bulk Actions Bar -->
    <div class="panel p-3">
        <div class="flex flex-wrap items-center gap-3">
            <!-- Selection Info -->
            <div class="flex items-center gap-2">
                <input type="checkbox"
                       id="batch-select-all"
                       onchange="toggleBatchSelectAll(this)"
                       class="h-4 w-4 rounded theme-border text-accent-500 focus:ring-accent-500">
                <span class="text-sm theme-text-secondary">
                    <span id="batch-selection-count" class="font-semibold">0</span> selected
                </span>
            </div>

            <div class="h-6 w-px theme-bg-tertiary"></div>

            <!-- Pipeline Operations Dropdown -->
            <div class="relative" x-data="{ open: false }" @click.away="open = false">
                <button @click="open = !open"
                        id="batch-process-btn"
                        disabled
                        class="btn btn-success btn-md flex items-center gap-2">
                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                    </svg>
                    <span>Run Pipeline</span>
                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                    </svg>
                </button>
                <div x-show="open" x-cloak x-transition
                     class="absolute left-0 mt-2 w-64 rounded-lg shadow-xl bg-white dark:bg-gray-800 border theme-border z-[100]">
                    <div class="py-1">
                        <div class="px-4 py-2 text-xs font-semibold theme-text-tertiary uppercase tracking-wide border-b theme-border">
                            Pipeline Operations
                        </div>
                        <button @click="executeBatchOperation('full-extraction'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-green-100 dark:bg-green-900 flex items-center justify-center">
                                <svg class="w-3 h-3 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                                </svg>
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm">Full Extraction</div>
                                <div class="text-xs theme-text-tertiary">JD + Research + CV</div>
                            </div>
                        </button>
                        <button @click="executeBatchOperation('process-jd'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center">
                                <svg class="w-3 h-3 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                                </svg>
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm">Extract JD</div>
                                <div class="text-xs theme-text-tertiary">Parse job description</div>
                            </div>
                        </button>
                        <button @click="executeBatchOperation('research-company'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-purple-100 dark:bg-purple-900 flex items-center justify-center">
                                <svg class="w-3 h-3 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                                </svg>
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm">Research Company</div>
                                <div class="text-xs theme-text-tertiary">Company intel</div>
                            </div>
                        </button>
                        <button @click="executeBatchOperation('generate-cv'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-yellow-100 dark:bg-yellow-900 flex items-center justify-center">
                                <svg class="w-3 h-3 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                                </svg>
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm">Generate CV</div>
                                <div class="text-xs theme-text-tertiary">Tailored CV</div>
                            </div>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Tier Selection -->
            <div class="relative" x-data="{ open: false }" @click.away="open = false">
                <input type="hidden" id="batch-tier" value="auto">
                <button @click="open = !open"
                        class="btn btn-ghost btn-md flex items-center gap-2">
                    <span id="batch-tier-label">Tier: Auto</span>
                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                    </svg>
                </button>
                <div x-show="open" x-cloak x-transition
                     class="absolute left-0 mt-2 w-48 rounded-lg shadow-xl bg-white dark:bg-gray-800 border theme-border z-[100]">
                    <div class="py-1">
                        <button @click="setBatchTier('auto'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 text-sm">
                            Auto (by score)
                        </button>
                        <button @click="setBatchTier('A'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 text-sm">
                            Gold (A)
                        </button>
                        <button @click="setBatchTier('B'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 text-sm">
                            Silver (B)
                        </button>
                        <button @click="setBatchTier('C'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 text-sm">
                            Bronze (C)
                        </button>
                    </div>
                </div>
            </div>

            <div class="h-6 w-px theme-bg-tertiary"></div>

            <!-- Status Actions -->
            <button id="batch-mark-applied-btn"
                    onclick="batchUpdateStatus('applied')"
                    disabled
                    class="btn btn-primary btn-md">
                <svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                </svg>
                Mark Applied
            </button>

            <button id="batch-mark-ready-btn"
                    onclick="batchUpdateStatus('ready for applying')"
                    disabled
                    class="btn btn-secondary btn-md">
                <svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                </svg>
                Mark Ready
            </button>

            <button id="batch-discard-btn"
                    onclick="batchUpdateStatus('discarded')"
                    disabled
                    class="btn btn-ghost btn-md text-orange-600 hover:bg-orange-50 dark:hover:bg-orange-900/20">
                <svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"/>
                </svg>
                Discard
            </button>

            <button id="batch-delete-btn"
                    onclick="openBatchDeleteModal()"
                    disabled
                    class="btn btn-danger btn-md">
                <svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
                Delete
            </button>
        </div>
    </div>

    <!-- Job Table -->
    <div class="card">
        <div class="overflow-x-auto">
            <!-- HTMX Loading Indicator (hidden by default, shown during requests) -->
            <div class="htmx-indicator text-center py-2 bg-blue-50 dark:bg-blue-900/20 border-b theme-border">
                <div class="flex items-center justify-center gap-2">
                    <svg class="animate-spin h-4 w-4 text-blue-500" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span class="text-sm text-blue-600 dark:text-blue-400">Refreshing...</span>
                </div>
            </div>
            <div id="batch-table-container"
                 hx-get="/partials/batch-job-rows"
                 hx-trigger="load, refresh from:body"
                 hx-indicator=".htmx-indicator">
                <!-- Table content loaded via HTMX -->
                <div class="p-8 text-center theme-text-tertiary">
                    <div class="spinner mx-auto mb-4"></div>
                    <p class="mt-2 text-sm font-medium theme-text-secondary">Loading batch queue...</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="batch-delete-modal" class="fixed inset-0 z-50 hidden" aria-modal="true">
    <div class="fixed inset-0 bg-black/50 backdrop-blur-sm" onclick="closeBatchDeleteModal()"></div>
    <div class="fixed inset-0 flex items-center justify-center p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6 relative">
            <h3 class="text-lg font-semibold theme-text-primary mb-2">Delete Selected Jobs?</h3>
            <p class="text-sm theme-text-secondary mb-4">
                This will permanently delete <span id="delete-count" class="font-semibold">0</span> jobs.
                This action cannot be undone.
            </p>
            <div class="flex justify-end gap-3">
                <button onclick="closeBatchDeleteModal()" class="btn btn-ghost btn-md">Cancel</button>
                <button onclick="confirmBatchDelete()" class="btn btn-danger btn-md">Delete</button>
            </div>
        </div>
    </div>
</div>

<!-- Keyboard Shortcuts Help Modal -->
<div id="keyboard-shortcuts-modal" class="fixed inset-0 z-50 hidden" aria-modal="true">
    <div class="fixed inset-0 bg-black/50 backdrop-blur-sm" onclick="closeKeyboardShortcutsHelp()"></div>
    <div class="fixed inset-0 flex items-center justify-center p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6 relative">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold theme-text-primary">Keyboard Shortcuts</h3>
                <button onclick="closeKeyboardShortcutsHelp()" class="text-gray-400 hover:text-gray-600">
                    <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="space-y-3">
                <div class="flex items-center justify-between py-2 border-b theme-border">
                    <span class="text-sm theme-text-secondary">Select all jobs</span>
                    <kbd class="px-2 py-1 text-xs font-semibold bg-gray-100 dark:bg-gray-700 rounded">Ctrl + A</kbd>
                </div>
                <div class="flex items-center justify-between py-2 border-b theme-border">
                    <span class="text-sm theme-text-secondary">Run full extraction on selected</span>
                    <kbd class="px-2 py-1 text-xs font-semibold bg-gray-100 dark:bg-gray-700 rounded">Ctrl + Enter</kbd>
                </div>
                <div class="flex items-center justify-between py-2 border-b theme-border">
                    <span class="text-sm theme-text-secondary">Clear selection</span>
                    <kbd class="px-2 py-1 text-xs font-semibold bg-gray-100 dark:bg-gray-700 rounded">Escape</kbd>
                </div>
                <div class="flex items-center justify-between py-2 border-b theme-border">
                    <span class="text-sm theme-text-secondary">Mark selected as discarded</span>
                    <kbd class="px-2 py-1 text-xs font-semibold bg-gray-100 dark:bg-gray-700 rounded">D</kbd>
                </div>
                <div class="flex items-center justify-between py-2">
                    <span class="text-sm theme-text-secondary">Mark selected as applied</span>
                    <kbd class="px-2 py-1 text-xs font-semibold bg-gray-100 dark:bg-gray-700 rounded">A</kbd>
                </div>
            </div>
            <p class="mt-4 text-xs theme-text-tertiary">
                Note: Single-key shortcuts (A, D) only work when no input field is focused.
            </p>
        </div>
    </div>
</div>

<!-- Floating Action Bar (shown when jobs are selected) -->
<div id="floating-action-bar"
     class="fixed left-1/2 transform -translate-x-1/2 z-40 hidden transition-all duration-300 ease-out"
     style="bottom: 56px;">
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl border theme-border px-4 py-3 flex items-center gap-4">
        <!-- Selection count -->
        <div class="flex items-center gap-2 pr-4 border-r theme-border">
            <span class="inline-flex items-center justify-center w-6 h-6 rounded-full bg-indigo-100 dark:bg-indigo-900 text-indigo-600 dark:text-indigo-400 text-sm font-semibold" id="floating-selection-count">0</span>
            <span class="text-sm theme-text-secondary">selected</span>
        </div>

        <!-- Quick Actions -->
        <button onclick="executeBatchOperation('full-extraction')"
                class="btn btn-success btn-sm flex items-center gap-2"
                title="Run Full Extraction (Ctrl+Enter)">
            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
            </svg>
            <span>Run Pipeline</span>
        </button>

        <button onclick="batchUpdateStatus('applied')"
                class="btn btn-primary btn-sm flex items-center gap-2"
                title="Mark as Applied (A)">
            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
            </svg>
            <span>Applied</span>
        </button>

        <button onclick="batchUpdateStatus('discarded')"
                class="btn btn-ghost btn-sm text-orange-600 hover:bg-orange-50 dark:hover:bg-orange-900/20 flex items-center gap-2"
                title="Mark as Discarded (D)">
            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"/>
            </svg>
            <span>Discard</span>
        </button>

        <!-- Clear selection -->
        <button onclick="clearBatchSelection()"
                class="btn btn-ghost btn-sm text-gray-500"
                title="Clear Selection (Escape)">
            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
        </button>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- BatchDebug utility - must load before batch-specific scripts -->
<script src="{{ url_for('static', filename='js/batch-debug.js') }}"></script>
<style>
/* Expanded row styling for batch processing table */
.expanded-detail-row {
    position: relative;
    z-index: 5; /* Below sticky header (z-index: 20) */
}

.expanded-detail-row td {
    max-width: 0; /* Forces content to respect colspan */
}

/* Ensure Application URL field doesn't overflow */
.expanded-detail-row input[type="url"] {
    max-width: 100%;
    min-width: 200px;
}

/* Fix truncation issues in expanded content */
.expanded-detail-row .truncate {
    max-width: 300px;
}
</style>
<script>
    // ============================================================================
    // Batch Processing State
    // ============================================================================

    const batchSelectedJobs = new Set();
    const tierLabels = { 'auto': 'Auto', 'A': 'Gold (A)', 'B': 'Silver (B)', 'C': 'Bronze (C)' };

    // Batch operation tracking
    const batchOperationState = {
        active: false,
        totalJobs: 0,
        completedJobs: 0,
        jobStatuses: new Map(), // jobId -> { status: 'pending'|'running'|'success'|'error', title: string }
        cancelled: false
    };

    // Active SSE connection for bulk operations
    let activeBatchSSE = null;

    // ============================================================================
    // SSE Streaming for Bulk Operations
    // ============================================================================

    /**
     * Start SSE stream for a bulk operation
     * Connects to the runner service's log stream for real-time updates
     * @param {string} runId - The run ID returned from the bulk operation
     * @param {string} operation - Operation name for logging
     */
    function connectBatchSSEStream(runId, operation) {
        BatchDebug.log('SSE', `Connecting to stream for run ${runId}`, { operation });

        // Close any existing connection
        if (activeBatchSSE) {
            BatchDebug.log('SSE', 'Closing previous SSE connection');
            activeBatchSSE.close();
            activeBatchSSE = null;
        }

        const logStreamUrl = `/api/runner/operations/${runId}/logs`;
        BatchDebug.log('SSE', `Creating EventSource: ${logStreamUrl}`);

        try {
            activeBatchSSE = new EventSource(logStreamUrl);

            activeBatchSSE.onopen = function() {
                BatchDebug.log('SSE', 'Connection opened', { readyState: activeBatchSSE.readyState });
            };

            // Handle regular log messages
            activeBatchSSE.onmessage = function(event) {
                BatchDebug.log('SSE', 'Log message', event.data);
                // Append to CLI panel if available
                if (window.cliPanel && typeof window.cliPanel.appendOutput === 'function') {
                    window.cliPanel.appendOutput(event.data, 'info');
                }
            };

            // Handle status events (job started, completed, etc.)
            activeBatchSSE.addEventListener('status', function(event) {
                BatchDebug.log('SSE', 'Status event received', event.data);
                try {
                    const statusData = JSON.parse(event.data);
                    handleBatchSSEStatus(statusData);
                } catch (e) {
                    BatchDebug.error('SSE', 'Failed to parse status event', e);
                }
            });

            // Handle layer status updates
            activeBatchSSE.addEventListener('layer_status', function(event) {
                BatchDebug.log('SSE', 'Layer status event', event.data);
                try {
                    const layerData = JSON.parse(event.data);
                    // Dispatch to CLI panel
                    window.dispatchEvent(new CustomEvent('cli:layer-status', {
                        detail: { runId, layerStatus: layerData }
                    }));
                } catch (e) {
                    BatchDebug.error('SSE', 'Failed to parse layer_status', e);
                }
            });

            // Handle completion
            activeBatchSSE.addEventListener('end', function(event) {
                const status = event.data;
                BatchDebug.log('SSE', `Stream ended with status: ${status}`);
                activeBatchSSE.close();
                activeBatchSSE = null;
            });

            // Handle errors
            activeBatchSSE.onerror = function(err) {
                BatchDebug.error('SSE', 'Connection error', err);
                // Don't immediately close - EventSource will try to reconnect
                // If we want to close, we can check readyState
                if (activeBatchSSE.readyState === EventSource.CLOSED) {
                    BatchDebug.log('SSE', 'Connection closed by server');
                    activeBatchSSE = null;
                }
            };

        } catch (e) {
            BatchDebug.error('SSE', 'Failed to create EventSource', e);
        }
    }

    /**
     * Handle status events from SSE stream
     * Updates progress badges and dispatches synthetic queue events
     * @param {Object} statusData - Status data from SSE event
     */
    function handleBatchSSEStatus(statusData) {
        BatchDebug.log('QUEUE', 'Processing status update', statusData);

        const { job_id, status, operation, progress, error } = statusData;

        // Update job progress in batch operation state
        if (job_id && batchOperationState.jobStatuses.has(job_id)) {
            const mappedStatus = mapSSEStatusToBatchStatus(status);
            updateJobProgress(job_id, mappedStatus);

            if (mappedStatus === 'success' || mappedStatus === 'error') {
                batchOperationState.completedJobs++;
                updateBatchProgressUI();
            }
        }

        // Dispatch synthetic queue event to update live status badges
        dispatchSyntheticQueueEvent(statusData);
    }

    /**
     * Map SSE status strings to batch operation status strings
     * @param {string} sseStatus - Status from SSE event
     * @returns {string} Mapped status for batch operation
     */
    function mapSSEStatusToBatchStatus(sseStatus) {
        const statusMap = {
            'started': 'running',
            'running': 'running',
            'completed': 'success',
            'success': 'success',
            'failed': 'error',
            'error': 'error',
            'queued': 'queued',
            'pending': 'pending'
        };
        return statusMap[sseStatus] || sseStatus;
    }

    /**
     * Dispatch synthetic queue event to update Alpine.js queue store
     * This makes live status badges update even for bulk operations
     * @param {Object} statusData - Status data from SSE
     */
    function dispatchSyntheticQueueEvent(statusData) {
        BatchDebug.log('QUEUE', 'Dispatching synthetic queue event', statusData);

        // Update Alpine queue store directly if available
        if (window.Alpine && Alpine.store('queue')) {
            const store = Alpine.store('queue');
            const { job_id, status, operation } = statusData;

            // Map SSE status to queue store status
            const queueStatus = mapSSEStatusToBatchStatus(status);

            // Update the queue store's job tracking
            if (job_id) {
                // If job is starting, add to active jobs
                if (queueStatus === 'running') {
                    store.currentJobId = job_id;
                    store.currentOperation = operation || store.currentOperation;
                }

                // Dispatch custom event for live_status_badge.html to react to
                document.dispatchEvent(new CustomEvent('queue:job-status-changed', {
                    detail: {
                        jobId: job_id,
                        status: queueStatus,
                        operation: operation
                    }
                }));

                // Also dispatch the specific events that existing code listens for
                if (queueStatus === 'running') {
                    document.dispatchEvent(new CustomEvent('queue:job-started', {
                        detail: { jobId: job_id, operation }
                    }));
                } else if (queueStatus === 'success') {
                    document.dispatchEvent(new CustomEvent('queue:job-completed', {
                        detail: { jobId: job_id, operation }
                    }));
                } else if (queueStatus === 'error') {
                    document.dispatchEvent(new CustomEvent('queue:job-failed', {
                        detail: { jobId: job_id, error: statusData.error }
                    }));
                }
            }
        }
    }

    /**
     * Close active SSE connection
     */
    function closeBatchSSE() {
        if (activeBatchSSE) {
            BatchDebug.log('SSE', 'Manually closing SSE connection');
            activeBatchSSE.close();
            activeBatchSSE = null;
        }
    }

    // ============================================================================
    // Expanded Row State Management (persists across HTMX swaps)
    // ============================================================================

    // Track expanded job IDs in Set (restored from sessionStorage)
    const expandedJobIds = new Set(
        JSON.parse(sessionStorage.getItem('batch_expanded_jobs') || '[]')
    );

    /**
     * Toggle expansion state for a job row
     * @param {string} jobId - The job ID to toggle
     * @returns {boolean} - The new expanded state
     */
    function toggleJobExpand(jobId) {
        if (expandedJobIds.has(jobId)) {
            expandedJobIds.delete(jobId);
        } else {
            expandedJobIds.add(jobId);
        }
        saveExpandedState();
        return expandedJobIds.has(jobId);
    }

    /**
     * Check if a job row is expanded
     * @param {string} jobId - The job ID to check
     * @returns {boolean} - Whether the row is expanded
     */
    function isJobExpanded(jobId) {
        return expandedJobIds.has(jobId);
    }

    /**
     * Save expanded state to sessionStorage
     */
    function saveExpandedState() {
        sessionStorage.setItem('batch_expanded_jobs', JSON.stringify([...expandedJobIds]));
    }

    /**
     * Restore expanded rows after HTMX swap
     * Updates Alpine.js component state for rows that were previously expanded
     */
    function restoreExpandedRows() {
        document.querySelectorAll('tbody[data-job-id]').forEach(tbody => {
            const jobId = tbody.dataset.jobId;
            if (expandedJobIds.has(jobId)) {
                // Access Alpine.js data stack and set expanded = true
                if (tbody._x_dataStack && tbody._x_dataStack[0]) {
                    tbody._x_dataStack[0].expanded = true;
                }
            }
        });
    }

    // ============================================================================
    // Selection Management
    // ============================================================================

    function toggleBatchSelectAll(checkbox) {
        const rows = document.querySelectorAll('.batch-row-checkbox');
        rows.forEach(row => {
            row.checked = checkbox.checked;
            const jobId = row.dataset.jobId;
            if (checkbox.checked) {
                batchSelectedJobs.add(jobId);
            } else {
                batchSelectedJobs.delete(jobId);
            }
        });
        updateBatchSelectionUI();
    }

    function toggleBatchRowSelection(checkbox) {
        const jobId = checkbox.dataset.jobId;
        if (checkbox.checked) {
            batchSelectedJobs.add(jobId);
        } else {
            batchSelectedJobs.delete(jobId);
        }
        updateBatchSelectionUI();
    }

    function updateBatchSelectionUI() {
        const count = batchSelectedJobs.size;
        document.getElementById('batch-selection-count').textContent = count;

        // Enable/disable buttons based on selection
        const hasSelection = count > 0;
        document.getElementById('batch-process-btn').disabled = !hasSelection;
        document.getElementById('batch-mark-applied-btn').disabled = !hasSelection;
        document.getElementById('batch-mark-ready-btn').disabled = !hasSelection;
        document.getElementById('batch-discard-btn').disabled = !hasSelection;
        document.getElementById('batch-delete-btn').disabled = !hasSelection;

        // Update select-all checkbox state
        const allCheckboxes = document.querySelectorAll('.batch-row-checkbox');
        const selectAll = document.getElementById('batch-select-all');
        if (allCheckboxes.length === 0) {
            selectAll.checked = false;
            selectAll.indeterminate = false;
        } else if (count === 0) {
            selectAll.checked = false;
            selectAll.indeterminate = false;
        } else if (count === allCheckboxes.length) {
            selectAll.checked = true;
            selectAll.indeterminate = false;
        } else {
            selectAll.checked = false;
            selectAll.indeterminate = true;
        }

        // Update floating action bar visibility
        updateFloatingActionBar();
    }

    // ============================================================================
    // Floating Action Bar
    // ============================================================================

    function updateFloatingActionBar() {
        const floatingBar = document.getElementById('floating-action-bar');
        const floatingCount = document.getElementById('floating-selection-count');
        const count = batchSelectedJobs.size;

        if (count > 0) {
            floatingBar.classList.remove('hidden');
            floatingCount.textContent = count;
        } else {
            floatingBar.classList.add('hidden');
        }
    }

    // ============================================================================
    // Keyboard Shortcuts
    // ============================================================================

    function setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Skip if user is typing in an input field
            const activeElement = document.activeElement;
            const isInputFocused = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.tagName === 'SELECT' ||
                activeElement.isContentEditable
            );

            // Ctrl+A: Select all jobs
            if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                selectAllBatch();
                return;
            }

            // Ctrl+Enter: Execute full-extraction on selected
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                if (batchSelectedJobs.size > 0) {
                    executeBatchOperation('full-extraction');
                }
                return;
            }

            // Escape: Clear selection or close modals
            if (e.key === 'Escape') {
                // First try to close any open modals
                const deleteModal = document.getElementById('batch-delete-modal');
                const shortcutsModal = document.getElementById('keyboard-shortcuts-modal');

                if (!deleteModal.classList.contains('hidden')) {
                    closeBatchDeleteModal();
                    return;
                }
                if (!shortcutsModal.classList.contains('hidden')) {
                    closeKeyboardShortcutsHelp();
                    return;
                }

                // Otherwise clear selection
                clearBatchSelection();
                return;
            }

            // Skip single-key shortcuts if input is focused
            if (isInputFocused) return;

            // 'd': Mark selected as discarded
            if (e.key === 'd' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                if (batchSelectedJobs.size > 0) {
                    batchUpdateStatus('discarded');
                }
                return;
            }

            // 'a' (without Ctrl): Mark selected as applied
            if (e.key === 'a' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                if (batchSelectedJobs.size > 0) {
                    batchUpdateStatus('applied');
                }
                return;
            }
        });
    }

    function selectAllBatch() {
        const rows = document.querySelectorAll('.batch-row-checkbox');
        rows.forEach(row => {
            row.checked = true;
            batchSelectedJobs.add(row.dataset.jobId);
        });
        document.getElementById('batch-select-all').checked = true;
        updateBatchSelectionUI();
        showToast(`Selected ${rows.length} jobs`, 'info');
    }

    function clearBatchSelection() {
        const rows = document.querySelectorAll('.batch-row-checkbox');
        rows.forEach(row => {
            row.checked = false;
        });
        batchSelectedJobs.clear();
        document.getElementById('batch-select-all').checked = false;
        document.getElementById('batch-select-all').indeterminate = false;
        updateBatchSelectionUI();
    }

    // ============================================================================
    // Keyboard Shortcuts Help Modal
    // ============================================================================

    function toggleKeyboardShortcutsHelp() {
        const modal = document.getElementById('keyboard-shortcuts-modal');
        if (modal.classList.contains('hidden')) {
            modal.classList.remove('hidden');
        } else {
            modal.classList.add('hidden');
        }
    }

    function closeKeyboardShortcutsHelp() {
        document.getElementById('keyboard-shortcuts-modal').classList.add('hidden');
    }

    // ============================================================================
    // Tier Selection
    // ============================================================================

    function setBatchTier(tier) {
        document.getElementById('batch-tier').value = tier;
        document.getElementById('batch-tier-label').textContent = `Tier: ${tierLabels[tier] || tier}`;
    }

    // ============================================================================
    // Pipeline Operations
    // ============================================================================

    async function executeBatchOperation(operation) {
        if (batchSelectedJobs.size === 0) return;

        const tier = document.getElementById('batch-tier').value || 'B';
        const tierDisplay = tierLabels[tier] || tier;
        const count = batchSelectedJobs.size;
        const jobIds = Array.from(batchSelectedJobs);

        BatchDebug.log('BATCH', `Starting ${operation}`, { count, tier, jobIds });

        const operationNames = {
            'full-extraction': 'Full Extraction',
            'process-jd': 'JD Extraction',
            'research-company': 'Company Research',
            'generate-cv': 'CV Generation'
        };

        // Map operations to their bulk endpoints
        const bulkEndpoints = {
            'full-extraction': '/api/runner/jobs/full-extraction/bulk',
            'process-jd': '/api/runner/jobs/full-extraction/bulk',
            'research-company': '/api/runner/jobs/research-company/bulk',
            'generate-cv': '/api/runner/jobs/generate-cv/bulk'
        };

        const confirmed = confirm(
            `Run ${operationNames[operation] || operation} on ${count} job${count > 1 ? 's' : ''}?\n\n` +
            `Tier: ${tierDisplay}\n` +
            `Jobs will be queued and processed. Check Pipeline Queue for progress.`
        );

        if (!confirmed) {
            BatchDebug.log('BATCH', 'Operation cancelled by user');
            return;
        }

        // Initialize progress tracking
        initBatchProgress(jobIds, operationNames[operation] || operation);

        try {
            showToast(`Starting ${operationNames[operation]} for ${count} jobs...`, 'info');

            // Use the appropriate bulk endpoint for the operation
            const endpoint = bulkEndpoints[operation];
            if (!endpoint) {
                BatchDebug.error('BATCH', `Unknown operation: ${operation}`);
                showToast(`Unknown operation: ${operation}`, 'error');
                hideBatchProgress();
                return;
            }

            BatchDebug.log('BATCH', `Calling bulk endpoint`, { endpoint });

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    job_ids: jobIds,
                    tier: tier,
                    use_llm: true,  // For full-extraction
                    force_refresh: false  // For research-company
                })
            });

            const result = await response.json();
            BatchDebug.log('BATCH', 'Bulk endpoint response', result);

            if (response.ok && result.runs) {
                // Success - jobs are queued
                showToast(`Queued ${result.total_count} jobs for ${operationNames[operation]}. Check Pipeline Queue for progress.`, 'success');

                // Mark all jobs as queued in progress panel
                result.runs.forEach(run => {
                    BatchDebug.log('PROGRESS', `Job ${run.job_id} queued with run_id ${run.run_id}`);
                    updateJobProgress(run.job_id, 'queued');

                    // Connect SSE stream for the first job to get real-time logs
                    // Note: For true bulk SSE, we'd need a bulk log stream endpoint
                    if (run.run_id && result.runs.indexOf(run) === 0) {
                        BatchDebug.log('SSE', `Connecting to SSE for first job: ${run.run_id}`);
                        connectBatchSSEStream(run.run_id, operation);
                    }
                });

                // Start polling for status updates via WebSocket queue
                startBatchProgressPolling();
            } else {
                BatchDebug.error('BATCH', 'Bulk endpoint failed', result);
                showToast(result.error || result.detail || 'Failed to start batch', 'error');
                hideBatchProgress();
            }
        } catch (err) {
            BatchDebug.error('BATCH', 'Batch operation failed', err);
            showToast('Batch operation failed: ' + err.message, 'error');
            hideBatchProgress();
        }
    }

    // ============================================================================
    // Progress Panel Management
    // ============================================================================

    function initBatchProgress(jobIds, operationName) {
        batchOperationState.active = true;
        batchOperationState.totalJobs = jobIds.length;
        batchOperationState.completedJobs = 0;
        batchOperationState.cancelled = false;
        batchOperationState.jobStatuses.clear();

        // Get job titles from the table
        jobIds.forEach(jobId => {
            const row = document.querySelector(`[data-job-id="${jobId}"]`);
            const titleEl = row ? row.closest('tr')?.querySelector('.job-title-link') : null;
            const title = titleEl ? titleEl.textContent.trim() : `Job ${jobId.slice(-6)}`;
            batchOperationState.jobStatuses.set(jobId, { status: 'pending', title });
        });

        // Show progress panel
        const panel = document.getElementById('batch-progress-panel');
        panel.classList.remove('hidden');

        updateBatchProgressUI();
        renderProgressDetails();
    }

    function updateBatchProgressUI() {
        const { totalJobs, completedJobs } = batchOperationState;
        const percentage = totalJobs > 0 ? Math.round((completedJobs / totalJobs) * 100) : 0;

        document.getElementById('batch-progress-completed').textContent = completedJobs;
        document.getElementById('batch-progress-total').textContent = totalJobs;
        document.getElementById('batch-progress-bar').style.width = `${percentage}%`;
    }

    function updateJobProgress(jobId, status) {
        const job = batchOperationState.jobStatuses.get(jobId);
        if (job) {
            job.status = status;
            renderProgressDetails();
        }
    }

    // Progress display constants (moved outside function to avoid allocation per iteration)
    const PROGRESS_STATUS_ICONS = {
        pending: '<span class="text-gray-400">○</span>',
        queued: '<span class="text-yellow-500">◉</span>',
        running: '<span class="text-blue-500 animate-pulse">●</span>',
        success: '<span class="text-green-500">✓</span>',
        extracted: '<span class="text-green-600">✓</span>',
        error: '<span class="text-red-500">✗</span>'
    };

    const PROGRESS_STATUS_CLASSES = {
        pending: 'text-gray-500',
        queued: 'text-yellow-600',
        running: 'text-blue-600 font-medium',
        success: 'text-green-600',
        extracted: 'text-green-700 font-medium',
        error: 'text-red-600'
    };

    // Track pending render to avoid duplicate RAF calls
    let _progressRenderPending = false;

    function renderProgressDetails() {
        // Debounce: skip if render already scheduled
        if (_progressRenderPending) return;
        _progressRenderPending = true;

        // Use requestAnimationFrame to yield to browser and avoid blocking UI
        requestAnimationFrame(() => {
            _progressRenderPending = false;

            const container = document.getElementById('batch-progress-details');
            const items = [];

            batchOperationState.jobStatuses.forEach((job, jobId) => {
                items.push(`
                    <div class="flex items-center gap-2 text-xs ${PROGRESS_STATUS_CLASSES[job.status]}">
                        ${PROGRESS_STATUS_ICONS[job.status]}
                        <span class="truncate">${job.title}</span>
                    </div>
                `);
            });

            container.innerHTML = items.join('');
        });
    }

    function hideBatchProgress() {
        BatchDebug.log('PROGRESS', 'Hiding progress panel');
        batchOperationState.active = false;
        document.getElementById('batch-progress-panel').classList.add('hidden');
        // Clean up SSE connection
        closeBatchSSE();
    }

    function cancelBatchOperation() {
        BatchDebug.log('BATCH', 'Operation cancelled by user');
        batchOperationState.cancelled = true;
        showToast('Batch operation cancelled', 'warning');
        hideBatchProgress();
    }

    function completeBatchOperation() {
        BatchDebug.log('BATCH', 'Operation complete');
        // Keep the panel visible for a moment to show completion
        const { totalJobs, completedJobs, jobStatuses } = batchOperationState;
        const successCount = Array.from(jobStatuses.values()).filter(j => j.status === 'success').length;
        const errorCount = Array.from(jobStatuses.values()).filter(j => j.status === 'error').length;

        // Update panel to show completion state
        const panel = document.getElementById('batch-progress-panel');
        const spinnerIcon = panel.querySelector('.animate-spin');
        if (spinnerIcon) {
            spinnerIcon.classList.remove('animate-spin');
            if (errorCount === 0) {
                spinnerIcon.innerHTML = '<path fill="currentColor" d="M5 13l4 4L19 7"/>';
                spinnerIcon.classList.remove('text-indigo-500');
                spinnerIcon.classList.add('text-green-500');
            } else {
                spinnerIcon.classList.remove('text-indigo-500');
                spinnerIcon.classList.add('text-orange-500');
            }
        }

        // Auto-hide after delay and refresh table
        setTimeout(() => {
            hideBatchProgress();
            // Refresh the table to show updated states
            htmx.trigger('#batch-table-container', 'refresh');
        }, 2000);
    }

    // Polling for bulk operations (when using the bulk runner endpoint)
    let batchProgressPollInterval = null;

    function startBatchProgressPolling() {
        BatchDebug.log('PROGRESS', 'Starting progress polling (every 2s)');

        // Poll every 2 seconds to check status
        batchProgressPollInterval = setInterval(async () => {
            if (!batchOperationState.active) {
                BatchDebug.log('PROGRESS', 'Stopping polling - batch no longer active');
                clearInterval(batchProgressPollInterval);
                return;
            }

            // Check status of each job via the CLI store if available
            const cliStore = window.Alpine?.store('cli');
            if (cliStore) {
                let runningCount = 0;
                let completeCount = 0;

                // OPTIMIZATION: Build lookup Map ONCE outside the loop (O(n) instead of O(n*n))
                const runs = Object.values(cliStore.runs || {});
                const runsByJobId = new Map(runs.map(r => [r.jobId, r]));

                batchOperationState.jobStatuses.forEach((job, jobId) => {
                    // O(1) lookup instead of O(n) find()
                    const jobRun = runsByJobId.get(jobId);

                    if (jobRun) {
                        if (jobRun.status === 'running') {
                            job.status = 'running';
                            runningCount++;
                        } else if (jobRun.status === 'success') {
                            job.status = 'success';
                            completeCount++;
                        } else if (jobRun.status === 'error') {
                            job.status = 'error';
                            completeCount++;
                        }
                    }
                });

                BatchDebug.log('PROGRESS', `Poll update: ${completeCount}/${batchOperationState.totalJobs} complete, ${runningCount} running`);

                batchOperationState.completedJobs = completeCount;
                updateBatchProgressUI();
                renderProgressDetails();

                // Check if all done
                if (completeCount >= batchOperationState.totalJobs) {
                    BatchDebug.log('PROGRESS', 'All jobs complete - stopping polling');
                    clearInterval(batchProgressPollInterval);
                    completeBatchOperation();
                }
            } else {
                BatchDebug.warn('PROGRESS', 'CLI store not available for polling');
            }
        }, 2000);
    }

    // ============================================================================
    // Status Updates
    // ============================================================================

    async function batchUpdateStatus(newStatus) {
        if (batchSelectedJobs.size === 0) return;

        const count = batchSelectedJobs.size;
        const confirmed = confirm(`Update ${count} job${count > 1 ? 's' : ''} to "${newStatus}"?`);
        if (!confirmed) return;

        try {
            const response = await fetch('/api/jobs/status/bulk', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    job_ids: Array.from(batchSelectedJobs),
                    status: newStatus
                })
            });

            const result = await response.json();
            if (result.success || response.ok) {
                showToast(`Updated ${result.updated_count || count} jobs to "${newStatus}"`, 'success');
                // Clear selection and refresh table
                batchSelectedJobs.clear();
                updateBatchSelectionUI();
                htmx.trigger('#batch-table-container', 'refresh');
            } else {
                showToast(result.error || 'Failed to update status', 'error');
            }
        } catch (err) {
            showToast('Status update failed: ' + err.message, 'error');
        }
    }

    async function updateBatchJobStatus(jobId, newStatus) {
        try {
            const response = await fetch('/api/jobs/status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ job_id: jobId, status: newStatus })
            });

            if (response.ok) {
                // If job is no longer "under processing", remove from view after a brief delay
                if (newStatus !== 'under processing') {
                    setTimeout(() => {
                        htmx.trigger('#batch-table-container', 'refresh');
                    }, 500);
                }
            } else {
                showToast('Failed to update status', 'error');
            }
        } catch (err) {
            showToast('Status update failed: ' + err.message, 'error');
        }
    }

    // ============================================================================
    // Delete Operations
    // ============================================================================

    function openBatchDeleteModal() {
        document.getElementById('delete-count').textContent = batchSelectedJobs.size;
        document.getElementById('batch-delete-modal').classList.remove('hidden');
    }

    function closeBatchDeleteModal() {
        document.getElementById('batch-delete-modal').classList.add('hidden');
    }

    async function confirmBatchDelete() {
        if (batchSelectedJobs.size === 0) return;

        try {
            const response = await fetch('/api/jobs/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ job_ids: Array.from(batchSelectedJobs) })
            });

            const result = await response.json();
            if (result.success || response.ok) {
                showToast(`Deleted ${result.deleted_count || batchSelectedJobs.size} jobs`, 'success');
                batchSelectedJobs.clear();
                updateBatchSelectionUI();
                closeBatchDeleteModal();
                htmx.trigger('#batch-table-container', 'refresh');
            } else {
                showToast(result.error || 'Failed to delete jobs', 'error');
            }
        } catch (err) {
            showToast('Delete failed: ' + err.message, 'error');
        }
    }

    // ============================================================================
    // Navigation & UI
    // ============================================================================

    function navigateToBatchJob(event, jobId) {
        // Don't navigate if clicking on interactive elements
        if (event.target.closest('input, select, button, a, .no-navigate')) {
            return;
        }
        window.location.href = `/job/${jobId}`;
    }

    // Update job count after HTMX load
    document.body.addEventListener('htmx:afterSwap', function(event) {
        if (event.detail.target.id === 'batch-table-container') {
            const rows = document.querySelectorAll('.batch-row-checkbox');
            document.getElementById('batch-job-count').innerHTML =
                `<span class="font-semibold">${rows.length}</span> jobs in queue`;

            // Restore selection state after refresh
            rows.forEach(checkbox => {
                if (batchSelectedJobs.has(checkbox.dataset.jobId)) {
                    checkbox.checked = true;
                }
            });
            updateBatchSelectionUI();

            // Restore expanded rows state after HTMX swap
            // Use setTimeout to ensure Alpine.js has initialized the new rows
            setTimeout(restoreExpandedRows, 50);
        }
    });

    // Clear selection on page load and initialize keyboard shortcuts
    document.addEventListener('DOMContentLoaded', function() {
        batchSelectedJobs.clear();
        updateBatchSelectionUI();
        setupKeyboardShortcuts();

        // Listen for WebSocket queue events to track actual extraction completion
        document.addEventListener('queue:job-started', function(e) {
            const jobId = e.detail?.jobId;
            if (jobId && batchOperationState.jobStatuses.has(jobId)) {
                updateJobProgress(jobId, 'running');
            }
        });

        document.addEventListener('queue:job-completed', function(e) {
            const jobId = e.detail?.jobId;
            if (jobId && batchOperationState.jobStatuses.has(jobId)) {
                updateJobProgress(jobId, 'extracted');
                batchOperationState.completedJobs++;
                updateBatchProgressUI();

                // Check if all batch jobs are done
                const allDone = Array.from(batchOperationState.jobStatuses.values())
                    .every(j => j.status === 'extracted' || j.status === 'error' || j.status === 'success');
                if (allDone && batchOperationState.active) {
                    const extractedCount = Array.from(batchOperationState.jobStatuses.values())
                        .filter(j => j.status === 'extracted' || j.status === 'success').length;
                    const totalCount = batchOperationState.jobStatuses.size;
                    showToast(`Extracted ${extractedCount}/${totalCount} jobs`, extractedCount === totalCount ? 'success' : 'warning');
                    completeBatchOperation();
                    // Refresh the table to show updated progress indicators
                    htmx.trigger(document.body, 'refresh');
                }
            }
        });

        document.addEventListener('queue:job-failed', function(e) {
            const jobId = e.detail?.jobId;
            if (jobId && batchOperationState.jobStatuses.has(jobId)) {
                updateJobProgress(jobId, 'error');
                batchOperationState.completedJobs++;
                updateBatchProgressUI();
            }
        });
    });
</script>
{% endblock %}
