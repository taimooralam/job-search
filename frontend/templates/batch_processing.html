{% extends "base.html" %}

{% block extra_head %}
<!-- CV Editor Styles (needed for batch CV sidebar) -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/cv-editor.css') }}">
<!-- JD Annotation Styles (needed for batch annotation sidebar) -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/jd-annotation.css') }}">
{% endblock %}

{% block content %}
<div class="space-y-4">
    <!-- Page Header -->
    <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
            <a href="/" class="btn btn-ghost btn-sm">
                <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                </svg>
                Back
            </a>
            <div>
                <h1 class="text-xl font-bold theme-text-primary">Batch Processing</h1>
                <p class="text-sm theme-text-secondary">Process multiple jobs at once</p>
            </div>
        </div>
        <div class="flex items-center gap-4">
            <!-- LinkedIn Multi-Import Dropdown -->
            {% include 'components/linkedin_import.html' %}
            <!-- Keyboard Shortcuts Help -->
            <button onclick="toggleKeyboardShortcutsHelp()"
                    class="btn btn-ghost btn-sm flex items-center gap-1"
                    title="Keyboard Shortcuts">
                <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707"/>
                </svg>
                <span class="hidden sm:inline">Shortcuts</span>
            </button>
            <span id="batch-job-count" class="text-sm theme-text-secondary">
                <span class="font-semibold">0</span> jobs in queue
            </span>
        </div>
    </div>

    <!-- Progress Overview Panel (hidden by default, shown when batch operations are running) -->
    <div id="batch-progress-panel" class="panel p-4 hidden">
        <div class="flex items-center justify-between mb-3">
            <div class="flex items-center gap-3">
                <svg class="h-5 w-5 text-indigo-500 animate-spin" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <div>
                    <h3 class="font-semibold theme-text-primary">Batch Operation in Progress</h3>
                    <p id="batch-progress-status" class="text-sm theme-text-secondary">
                        <span id="batch-progress-completed">0</span>/<span id="batch-progress-total">0</span> operations complete
                    </p>
                </div>
            </div>
            <button onclick="cancelBatchOperation()" class="btn btn-ghost btn-sm text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20">
                Cancel
            </button>
        </div>
        <!-- Progress Bar -->
        <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
            <div id="batch-progress-bar" class="bg-indigo-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <!-- Individual Job Progress -->
        <div id="batch-progress-details" class="mt-3 max-h-32 overflow-y-auto space-y-1">
            <!-- Populated dynamically -->
        </div>
    </div>

    <!-- Bulk Actions Bar -->
    <div class="panel p-3">
        <div class="flex flex-wrap items-center gap-3">
            <!-- Selection Info -->
            <div class="flex items-center gap-2">
                <input type="checkbox"
                       id="batch-select-all"
                       onchange="toggleBatchSelectAll(this)"
                       class="h-4 w-4 rounded theme-border text-accent-500 focus:ring-accent-500">
                <span class="text-sm theme-text-secondary">
                    <span id="batch-selection-count" class="font-semibold">0</span> selected
                </span>
            </div>

            <div class="h-6 w-px theme-bg-tertiary"></div>

            <!-- Pipeline Operations Dropdown (Unified Menu) -->
            <div class="relative" x-data="{ open: false }" @click.away="open = false">
                <button @click="open = !open"
                        id="batch-process-btn"
                        disabled
                        class="btn btn-success btn-md flex items-center gap-2">
                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                    </svg>
                    <span>Run Pipeline</span>
                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                    </svg>
                </button>
                <div x-show="open" x-cloak x-transition
                     class="absolute left-0 mt-2 w-72 rounded-lg shadow-xl bg-white dark:bg-gray-800 border theme-border z-[100]">
                    <div class="py-1">
                        <!-- Full Analysis (Hero Action) -->
                        <button @click="executeBatchOperation('full-analysis'); open = false"
                                class="w-full text-left px-4 py-3 hover:bg-indigo-50 dark:hover:bg-indigo-900/30 flex items-center gap-3 border-b theme-border bg-gradient-to-r from-indigo-50 to-purple-50 dark:from-indigo-900/20 dark:to-purple-900/20">
                            <span class="w-8 h-8 rounded-full bg-gradient-to-r from-indigo-500 to-purple-500 flex items-center justify-center text-white text-lg">
                                &#9889;
                            </span>
                            <div class="flex-1">
                                <div class="font-semibold text-sm theme-text-primary">Full Analysis</div>
                                <div class="text-xs theme-text-tertiary">Run all analysis steps in parallel</div>
                            </div>
                        </button>

                        <!-- ANALYSIS Section -->
                        <div class="px-4 py-2 text-xs font-semibold theme-text-tertiary uppercase tracking-wide border-b theme-border bg-gray-50 dark:bg-gray-900/50">
                            Analysis
                        </div>
                        <button @click="executeBatchOperation('analyze-job'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center text-sm">
                                &#128196;
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm theme-text-primary">Analyze Job</div>
                                <div class="text-xs theme-text-tertiary">Extract JD, identify pain points, calculate fit score</div>
                            </div>
                        </button>
                        <button @click="executeBatchOperation('prepare-annotations'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center text-sm">
                                &#9999;&#65039;
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm theme-text-primary">Prepare Annotations</div>
                                <div class="text-xs theme-text-tertiary">Structure JD into sections for annotation editor</div>
                            </div>
                        </button>

                        <!-- RESEARCH Section -->
                        <div class="px-4 py-2 text-xs font-semibold theme-text-tertiary uppercase tracking-wide border-b theme-border bg-gray-50 dark:bg-gray-900/50">
                            Research
                        </div>
                        <button @click="executeBatchOperation('research-company'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-purple-100 dark:bg-purple-900 flex items-center justify-center text-sm">
                                &#127970;
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm theme-text-primary">Research Company</div>
                                <div class="text-xs theme-text-tertiary">Gather company signals, funding, news, and role context</div>
                            </div>
                        </button>
                        <button @click="executeBatchOperation('discover-contacts'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-purple-100 dark:bg-purple-900 flex items-center justify-center text-sm">
                                &#128101;
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm theme-text-primary">Discover Contacts</div>
                                <div class="text-xs theme-text-tertiary">Find hiring managers, recruiters, and relevant peers</div>
                            </div>
                        </button>

                        <!-- GENERATION Section -->
                        <div class="px-4 py-2 text-xs font-semibold theme-text-tertiary uppercase tracking-wide border-b theme-border bg-gray-50 dark:bg-gray-900/50">
                            Generation
                        </div>
                        <button @click="executeBatchOperation('generate-cv'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-amber-100 dark:bg-amber-900 flex items-center justify-center text-sm">
                                &#128221;
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm theme-text-primary">Generate CV</div>
                                <div class="text-xs theme-text-tertiary">Create tailored CV matched to job requirements</div>
                            </div>
                        </button>
                        <button @click="executeBatchOperation('generate-cover-letter'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-amber-100 dark:bg-amber-900 flex items-center justify-center text-sm">
                                &#128140;
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm theme-text-primary">Generate Cover Letter</div>
                                <div class="text-xs theme-text-tertiary">Write personalized cover letter for this role</div>
                            </div>
                        </button>
                        <button @click="executeBatchOperation('generate-outreach'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3">
                            <span class="w-6 h-6 rounded-full bg-amber-100 dark:bg-amber-900 flex items-center justify-center text-sm">
                                &#128232;
                            </span>
                            <div class="flex-1">
                                <div class="font-medium text-sm theme-text-primary">Generate Outreach</div>
                                <div class="text-xs theme-text-tertiary">Create LinkedIn and email messages for contacts</div>
                            </div>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Unified Tier Selection (Fast/Balanced/Quality) -->
            <div class="relative" x-data="{ open: false }" @click.away="open = false">
                <input type="hidden" id="batch-tier" value="balanced">
                <button @click="open = !open"
                        class="btn btn-ghost btn-md flex items-center gap-2">
                    <span id="batch-tier-icon" class="text-base">&#9878;&#65039;</span>
                    <span id="batch-tier-label">Balanced</span>
                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                    </svg>
                </button>
                <div x-show="open" x-cloak x-transition
                     class="absolute left-0 mt-2 w-56 rounded-lg shadow-xl bg-white dark:bg-gray-800 border theme-border z-[100]">
                    <div class="py-1">
                        <div class="px-4 py-2 text-xs font-semibold theme-text-tertiary uppercase tracking-wide border-b theme-border">
                            Processing Tier
                        </div>
                        <button @click="setBatchTier('fast'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3"
                                data-tier="fast">
                            <span class="text-lg">&#9889;</span>
                            <div class="flex-1">
                                <div class="font-medium text-sm theme-text-primary">Fast</div>
                                <div class="text-xs theme-text-tertiary">gpt-4o-mini + claude-haiku</div>
                            </div>
                            <span class="text-xs theme-text-tertiary">~$0.02</span>
                        </button>
                        <button @click="setBatchTier('balanced'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3 bg-indigo-50 dark:bg-indigo-900/20"
                                data-tier="balanced">
                            <span class="text-lg">&#9878;&#65039;</span>
                            <div class="flex-1">
                                <div class="font-medium text-sm theme-text-primary">Balanced</div>
                                <div class="text-xs theme-text-tertiary">gpt-4o-mini + claude-sonnet</div>
                            </div>
                            <span class="text-xs theme-text-tertiary">~$0.05</span>
                        </button>
                        <button @click="setBatchTier('quality'); open = false"
                                class="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3"
                                data-tier="quality">
                            <span class="text-lg">&#10024;</span>
                            <div class="flex-1">
                                <div class="font-medium text-sm theme-text-primary">Quality</div>
                                <div class="text-xs theme-text-tertiary">gpt-4o + claude-opus-4.5</div>
                            </div>
                            <span class="text-xs theme-text-tertiary">~$0.50</span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="h-6 w-px theme-bg-tertiary"></div>

            <!-- Status Actions -->
            <button id="batch-mark-applied-btn"
                    onclick="batchUpdateStatus('applied')"
                    disabled
                    class="btn btn-primary btn-md">
                <svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                </svg>
                Mark Applied
            </button>

            <button id="batch-mark-ready-btn"
                    onclick="batchUpdateStatus('ready for applying')"
                    disabled
                    class="btn btn-secondary btn-md">
                <svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                </svg>
                Mark Ready
            </button>

            <button id="batch-discard-btn"
                    onclick="batchUpdateStatus('discarded')"
                    disabled
                    class="btn btn-ghost btn-md text-orange-600 hover:bg-orange-50 dark:hover:bg-orange-900/20">
                <svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"/>
                </svg>
                Discard
            </button>

            <button id="batch-delete-btn"
                    onclick="openBatchDeleteModal()"
                    disabled
                    class="btn btn-danger btn-md">
                <svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
                Delete
            </button>
        </div>
    </div>

    <!-- Job Table -->
    <div class="card">
        <div class="overflow-x-auto">
            <!-- HTMX Loading Indicator (hidden by default, shown during requests) -->
            <div class="htmx-indicator text-center py-2 bg-blue-50 dark:bg-blue-900/20 border-b theme-border">
                <div class="flex items-center justify-center gap-2">
                    <svg class="animate-spin h-4 w-4 text-blue-500" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span class="text-sm text-blue-600 dark:text-blue-400">Refreshing...</span>
                </div>
            </div>
            <div id="batch-table-container"
                 hx-get="/partials/batch-job-rows"
                 hx-trigger="load, refresh from:body"
                 hx-indicator=".htmx-indicator">
                <!-- Table content loaded via HTMX -->
                <div class="p-8 text-center theme-text-tertiary">
                    <div class="spinner mx-auto mb-4"></div>
                    <p class="mt-2 text-sm font-medium theme-text-secondary">Loading batch queue...</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="batch-delete-modal" class="fixed inset-0 z-50 hidden" aria-modal="true">
    <div class="fixed inset-0 bg-black/50 backdrop-blur-sm" onclick="closeBatchDeleteModal()"></div>
    <div class="fixed inset-0 flex items-center justify-center p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6 relative">
            <h3 class="text-lg font-semibold theme-text-primary mb-2">Delete Selected Jobs?</h3>
            <p class="text-sm theme-text-secondary mb-4">
                This will permanently delete <span id="delete-count" class="font-semibold">0</span> jobs.
                This action cannot be undone.
            </p>
            <div class="flex justify-end gap-3">
                <button onclick="closeBatchDeleteModal()" class="btn btn-ghost btn-md">Cancel</button>
                <button onclick="confirmBatchDelete()" class="btn btn-danger btn-md">Delete</button>
            </div>
        </div>
    </div>
</div>

<!-- Keyboard Shortcuts Help Modal -->
<div id="keyboard-shortcuts-modal" class="fixed inset-0 z-50 hidden" aria-modal="true">
    <div class="fixed inset-0 bg-black/50 backdrop-blur-sm" onclick="closeKeyboardShortcutsHelp()"></div>
    <div class="fixed inset-0 flex items-center justify-center p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6 relative">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold theme-text-primary">Keyboard Shortcuts</h3>
                <button onclick="closeKeyboardShortcutsHelp()" class="text-gray-400 hover:text-gray-600">
                    <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="space-y-3">
                <div class="flex items-center justify-between py-2 border-b theme-border">
                    <span class="text-sm theme-text-secondary">Select all jobs</span>
                    <kbd class="px-2 py-1 text-xs font-semibold bg-gray-100 dark:bg-gray-700 rounded">Ctrl + A</kbd>
                </div>
                <div class="flex items-center justify-between py-2 border-b theme-border">
                    <span class="text-sm theme-text-secondary">Run full analysis on selected</span>
                    <kbd class="px-2 py-1 text-xs font-semibold bg-gray-100 dark:bg-gray-700 rounded">Ctrl + Enter</kbd>
                </div>
                <div class="flex items-center justify-between py-2 border-b theme-border">
                    <span class="text-sm theme-text-secondary">Clear selection</span>
                    <kbd class="px-2 py-1 text-xs font-semibold bg-gray-100 dark:bg-gray-700 rounded">Escape</kbd>
                </div>
                <div class="flex items-center justify-between py-2 border-b theme-border">
                    <span class="text-sm theme-text-secondary">Mark selected as discarded</span>
                    <kbd class="px-2 py-1 text-xs font-semibold bg-gray-100 dark:bg-gray-700 rounded">D</kbd>
                </div>
                <div class="flex items-center justify-between py-2">
                    <span class="text-sm theme-text-secondary">Mark selected as applied</span>
                    <kbd class="px-2 py-1 text-xs font-semibold bg-gray-100 dark:bg-gray-700 rounded">A</kbd>
                </div>
            </div>
            <p class="mt-4 text-xs theme-text-tertiary">
                Note: Single-key shortcuts (A, D) only work when no input field is focused.
            </p>
        </div>
    </div>
</div>

<!-- Floating Action Bar (shown when jobs are selected) -->
<div id="floating-action-bar"
     class="fixed left-1/2 transform -translate-x-1/2 z-40 hidden transition-all duration-300 ease-out"
     style="bottom: 56px;">
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl border theme-border px-4 py-3 flex items-center gap-4">
        <!-- Selection count -->
        <div class="flex items-center gap-2 pr-4 border-r theme-border">
            <span class="inline-flex items-center justify-center w-6 h-6 rounded-full bg-indigo-100 dark:bg-indigo-900 text-indigo-600 dark:text-indigo-400 text-sm font-semibold" id="floating-selection-count">0</span>
            <span class="text-sm theme-text-secondary">selected</span>
        </div>

        <!-- Quick Actions -->
        <button onclick="executeBatchOperation('full-analysis')"
                class="btn btn-success btn-sm flex items-center gap-2"
                title="Run Full Analysis (Ctrl+Enter)">
            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
            </svg>
            <span>Full Analysis</span>
        </button>

        <button onclick="batchUpdateStatus('applied')"
                class="btn btn-primary btn-sm flex items-center gap-2"
                title="Mark as Applied (A)">
            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
            </svg>
            <span>Applied</span>
        </button>

        <button onclick="batchUpdateStatus('discarded')"
                class="btn btn-ghost btn-sm text-orange-600 hover:bg-orange-50 dark:hover:bg-orange-900/20 flex items-center gap-2"
                title="Mark as Discarded (D)">
            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"/>
            </svg>
            <span>Discard</span>
        </button>

        <!-- Clear selection -->
        <button onclick="clearBatchSelection()"
                class="btn btn-ghost btn-sm text-gray-500"
                title="Clear Selection (Escape)">
            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
        </button>
    </div>
</div>

{# Batch Page Sidebars - for JD annotations, contacts, and CV editor #}
{% include 'partials/batch/_batch_sidebars.html' %}

<!-- Batch Job Row Context Menu -->
<div id="batch-job-context-menu" class="cli-context-menu hidden" style="position: fixed; z-index: 9999;">
    <button onclick="batchContextMenuAction('open')" class="cli-context-item">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/>
        </svg>
        Open in New Tab
    </button>
    <button id="batch-context-menu-open-job-url" onclick="batchContextMenuAction('openJobUrl')" class="cli-context-item">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"/>
        </svg>
        Open Job URL
    </button>
    <div class="cli-context-divider"></div>
    <button onclick="batchContextMenuAction('process')" class="cli-context-item">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
        </svg>
        Process Job
    </button>
    <button onclick="batchContextMenuAction('applied')" class="cli-context-item">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
        </svg>
        Mark as Applied
    </button>
    <button onclick="batchContextMenuAction('discard')" class="cli-context-item">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"/>
        </svg>
        Discard
    </button>
</div>
{% endblock %}

{% block extra_js %}
<!-- BatchDebug utility - must load before batch-specific scripts -->
<script src="{{ url_for('static', filename='js/batch-debug.js') }}"></script>
<!-- CV Editor - TipTap based rich text editor (needed for batch CV sidebar) -->
<script src="{{ url_for('static', filename='js/cv-editor.js') }}"></script>
<!-- JD Annotation System Script (needed for batch annotation sidebar) -->
<script src="{{ url_for('static', filename='js/jd-annotation.js') }}"></script>
<!-- Batch Sidebars - manages JD annotation, contacts, and CV editor panels -->
<script src="{{ url_for('static', filename='js/batch-sidebars.js') }}"></script>
<style>
/* Expanded row styling for batch processing table */
.expanded-detail-row {
    position: relative;
    z-index: 5; /* Below sticky header (z-index: 20) */
}

.expanded-detail-row td {
    max-width: 0; /* Forces content to respect colspan */
}

/* Ensure Application URL field doesn't overflow */
.expanded-detail-row input[type="url"] {
    max-width: 100%;
    min-width: 200px;
}

/* Fix truncation issues in expanded content */
.expanded-detail-row .truncate {
    max-width: 300px;
}
</style>
<script>
    // ============================================================================
    // Batch Processing State
    // ============================================================================

    const batchSelectedJobs = new Set();

    // ============================================================================
    // Batch Job Context Menu
    // ============================================================================

    let batchContextMenuTargetJobId = null;
    let batchContextMenuTargetJobTitle = null;
    let batchContextMenuTargetJobUrl = null;

    function showBatchJobContextMenu(event, jobId, jobTitle, jobUrl) {
        event.preventDefault();
        event.stopPropagation();

        const menu = document.getElementById('batch-job-context-menu');
        if (!menu) return;

        // Store target job info
        batchContextMenuTargetJobId = jobId;
        batchContextMenuTargetJobTitle = jobTitle || 'this job';
        batchContextMenuTargetJobUrl = jobUrl || null;

        // Show/hide the "Open Job URL" option based on whether URL exists
        const openJobUrlBtn = document.getElementById('batch-context-menu-open-job-url');
        if (openJobUrlBtn) {
            openJobUrlBtn.style.display = jobUrl ? 'flex' : 'none';
        }

        // Position menu at click location, but ensure it stays on screen
        const menuWidth = 180;
        const menuHeight = 200;
        let x = event.clientX;
        let y = event.clientY;

        if (x + menuWidth > window.innerWidth) {
            x = window.innerWidth - menuWidth - 10;
        }
        if (y + menuHeight > window.innerHeight) {
            y = y - menuHeight;
        }

        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.classList.remove('hidden');

        setTimeout(() => {
            document.addEventListener('click', hideBatchContextMenuOnClickOutside);
            document.addEventListener('keydown', hideBatchContextMenuOnEscape);
        }, 0);
    }

    function hideBatchJobContextMenu() {
        const menu = document.getElementById('batch-job-context-menu');
        if (menu) {
            menu.classList.add('hidden');
        }
        batchContextMenuTargetJobId = null;
        batchContextMenuTargetJobTitle = null;
        batchContextMenuTargetJobUrl = null;
        document.removeEventListener('click', hideBatchContextMenuOnClickOutside);
        document.removeEventListener('keydown', hideBatchContextMenuOnEscape);
    }

    function hideBatchContextMenuOnClickOutside(event) {
        const menu = document.getElementById('batch-job-context-menu');
        if (menu && !menu.contains(event.target)) {
            hideBatchJobContextMenu();
        }
    }

    function hideBatchContextMenuOnEscape(event) {
        if (event.key === 'Escape') {
            hideBatchJobContextMenu();
        }
    }

    async function batchContextMenuAction(action) {
        const jobId = batchContextMenuTargetJobId;
        const jobTitle = batchContextMenuTargetJobTitle;
        const jobUrl = batchContextMenuTargetJobUrl;

        if (!jobId) {
            hideBatchJobContextMenu();
            return;
        }

        hideBatchJobContextMenu();

        switch (action) {
            case 'open':
                window.open(`/job/${jobId}`, '_blank');
                break;

            case 'openJobUrl':
                if (jobUrl) {
                    window.open(jobUrl, '_blank');
                } else {
                    showToast('No external URL available for this job', 'warning');
                }
                break;

            case 'process':
                processSingleBatchJob(jobId);
                break;

            case 'applied':
                await updateBatchJobStatus(jobId, 'applied');
                break;

            case 'discard':
                await updateBatchJobStatus(jobId, 'discarded');
                break;
        }
    }
    // Unified tier labels and icons (Phase 2 refactoring)
    const tierLabels = {
        'fast': 'Fast',
        'balanced': 'Balanced',
        'quality': 'Quality',
        // Legacy aliases for backward compatibility
        'auto': 'Balanced',
        'A': 'Quality',
        'B': 'Balanced',
        'C': 'Fast'
    };
    const tierIcons = {
        'fast': '\u26A1',      // Lightning bolt
        'balanced': '\u2696\uFE0F', // Balance scale
        'quality': '\u2728',   // Sparkles
        // Legacy aliases
        'auto': '\u2696\uFE0F',
        'A': '\u2728',
        'B': '\u2696\uFE0F',
        'C': '\u26A1'
    };
    // Operation name mappings (new -> backend)
    const operationAliases = {
        'full-analysis': 'all-ops',
        'analyze-job': 'full-extraction',
        'prepare-annotations': 'structure-jd',
        'discover-contacts': 'research-company',
        'generate-cover-letter': 'generate-cv',
        'generate-outreach': 'research-company'
    };
    // Operation display names
    const operationNames = {
        'full-analysis': 'Full Analysis',
        'analyze-job': 'Analyze Job',
        'prepare-annotations': 'Prepare Annotations',
        'research-company': 'Research Company',
        'discover-contacts': 'Discover Contacts',
        'generate-cv': 'Generate CV',
        'generate-cover-letter': 'Generate Cover Letter',
        'generate-outreach': 'Generate Outreach',
        // Legacy names
        'full-extraction': 'Analyze Job',
        'process-jd': 'Analyze Job',
        'structure-jd': 'Prepare Annotations',
        'all-ops': 'Full Analysis'
    };

    // Batch operation tracking
    const batchOperationState = {
        active: false,
        totalJobs: 0,
        completedJobs: 0,
        jobStatuses: new Map(), // jobId -> { status, title, runId } for tracking and cli:complete matching
        cancelled: false
    };

    // ============================================================================
    // CLI Panel Integration for Log Streaming
    // ============================================================================
    //
    // ARCHITECTURE: Batch page delegates ALL log polling to CLI panel.
    // We only dispatch cli:start-run events; the CLI panel creates and manages
    // LogPoller instances to avoid duplicate pollers conflicting.

    /**
     * Connect batch job to CLI panel for log streaming
     *
     * IMPORTANT: This function does NOT create its own LogPoller.
     * Instead, it dispatches a cli:start-run event and lets the CLI panel
     * handle all log polling via its existing infrastructure.
     *
     * This avoids the dual-poller conflict where both batch page and CLI panel
     * were creating separate LogPollers for the same runId.
     *
     * @param {string} runId - The run ID returned from the bulk operation
     * @param {string} jobId - The job ID for progress tracking
     * @param {string} operation - Operation name for logging
     * @param {string} jobTitle - Job title for CLI panel display
     */
    function connectBatchLogPoller(runId, jobId, operation, jobTitle) {
        BatchDebug.log('POLLER', `Delegating to CLI panel for run ${runId}`, { jobId, operation });

        // Dispatch CLI start event - CLI panel will create the LogPoller
        // and handle all log streaming via cli-panel.js startRun() method
        window.dispatchEvent(new CustomEvent('cli:start-run', {
            detail: {
                runId: runId,
                jobId: jobId,
                jobTitle: jobTitle || 'Unknown Job',
                action: operation
            }
        }));

        BatchDebug.log('POLLER', `Dispatched cli:start-run for ${runId} - CLI panel will handle log polling`);
    }

    /**
     * Handle status events from SSE stream
     * Updates progress badges and dispatches synthetic queue events
     * @param {Object} statusData - Status data from SSE event
     */
    function handleBatchSSEStatus(statusData) {
        BatchDebug.log('QUEUE', 'Processing status update', statusData);

        const { job_id, status, operation, progress, error } = statusData;

        // Update job progress in batch operation state
        if (job_id && batchOperationState.jobStatuses.has(job_id)) {
            const mappedStatus = mapSSEStatusToBatchStatus(status);
            updateJobProgress(job_id, mappedStatus);

            if (mappedStatus === 'success' || mappedStatus === 'error') {
                batchOperationState.completedJobs++;
                updateBatchProgressUI();
            }
        }

        // Dispatch synthetic queue event to update live status badges
        dispatchSyntheticQueueEvent(statusData);
    }

    /**
     * Map SSE status strings to batch operation status strings
     * @param {string} sseStatus - Status from SSE event
     * @returns {string} Mapped status for batch operation
     */
    function mapSSEStatusToBatchStatus(sseStatus) {
        const statusMap = {
            'started': 'running',
            'running': 'running',
            'completed': 'success',
            'success': 'success',
            'failed': 'error',
            'error': 'error',
            'queued': 'queued',
            'pending': 'pending'
        };
        return statusMap[sseStatus] || sseStatus;
    }

    /**
     * Dispatch synthetic queue event to update Alpine.js queue store
     * This makes live status badges update even for bulk operations
     * @param {Object} statusData - Status data from SSE
     */
    function dispatchSyntheticQueueEvent(statusData) {
        BatchDebug.log('QUEUE', 'Dispatching synthetic queue event', statusData);

        // Update Alpine queue store directly if available
        if (window.Alpine && Alpine.store('queue')) {
            const store = Alpine.store('queue');
            const { job_id, status, operation } = statusData;

            // Map SSE status to queue store status
            const queueStatus = mapSSEStatusToBatchStatus(status);

            // Update the queue store's job tracking
            if (job_id) {
                // If job is starting, add to active jobs
                if (queueStatus === 'running') {
                    store.currentJobId = job_id;
                    store.currentOperation = operation || store.currentOperation;
                }

                // Dispatch custom event for live_status_badge.html to react to
                // Note: Must use window (not document) since live-status-badge.js listens on window
                window.dispatchEvent(new CustomEvent('queue:job-status-changed', {
                    detail: {
                        jobId: job_id,
                        status: queueStatus,
                        operation: operation
                    }
                }));

                // Also dispatch the specific events that existing code listens for
                if (queueStatus === 'running') {
                    window.dispatchEvent(new CustomEvent('queue:job-started', {
                        detail: { jobId: job_id, operation }
                    }));
                } else if (queueStatus === 'success') {
                    window.dispatchEvent(new CustomEvent('queue:job-completed', {
                        detail: { jobId: job_id, operation }
                    }));
                } else if (queueStatus === 'error') {
                    window.dispatchEvent(new CustomEvent('queue:job-failed', {
                        detail: { jobId: job_id, error: statusData.error }
                    }));
                }
            }
        }
    }

    /**
     * Cleanup function for batch operations
     * NOTE: Log pollers are managed by CLI panel, so this is now a no-op stub
     * kept for backward compatibility with hideBatchProgress() calls
     */
    function cleanupBatchPollers() {
        // No-op: CLI panel manages all LogPoller instances
        BatchDebug.log('CLEANUP', 'Batch cleanup called (CLI panel manages pollers)');
    }

    // Alias for backward compatibility
    function closeBatchSSE() {
        cleanupBatchPollers();
    }

    // ============================================================================
    // Expanded Row State Management (persists across HTMX swaps)
    // ============================================================================

    // Track expanded job IDs in Set (restored from sessionStorage)
    const expandedJobIds = new Set(
        JSON.parse(sessionStorage.getItem('batch_expanded_jobs') || '[]')
    );

    /**
     * Toggle expansion state for a job row
     * @param {string} jobId - The job ID to toggle
     * @returns {boolean} - The new expanded state
     */
    function toggleJobExpand(jobId) {
        if (expandedJobIds.has(jobId)) {
            expandedJobIds.delete(jobId);
        } else {
            expandedJobIds.add(jobId);
        }
        saveExpandedState();
        return expandedJobIds.has(jobId);
    }

    /**
     * Check if a job row is expanded
     * @param {string} jobId - The job ID to check
     * @returns {boolean} - Whether the row is expanded
     */
    function isJobExpanded(jobId) {
        return expandedJobIds.has(jobId);
    }

    /**
     * Save expanded state to sessionStorage
     */
    function saveExpandedState() {
        sessionStorage.setItem('batch_expanded_jobs', JSON.stringify([...expandedJobIds]));
    }

    /**
     * Restore expanded rows after HTMX swap
     * Updates Alpine.js component state for rows that were previously expanded
     */
    function restoreExpandedRows() {
        document.querySelectorAll('tbody[data-job-id]').forEach(tbody => {
            const jobId = tbody.dataset.jobId;
            if (expandedJobIds.has(jobId)) {
                // Access Alpine.js data stack and set expanded = true
                if (tbody._x_dataStack && tbody._x_dataStack[0]) {
                    tbody._x_dataStack[0].expanded = true;
                }
            }
        });
    }

    // ============================================================================
    // Selection Management
    // ============================================================================

    function toggleBatchSelectAll(checkbox) {
        const rows = document.querySelectorAll('.batch-row-checkbox');
        rows.forEach(row => {
            row.checked = checkbox.checked;
            const jobId = row.dataset.jobId;
            if (checkbox.checked) {
                batchSelectedJobs.add(jobId);
            } else {
                batchSelectedJobs.delete(jobId);
            }
        });
        updateBatchSelectionUI();
    }

    function toggleBatchRowSelection(checkbox) {
        const jobId = checkbox.dataset.jobId;
        if (checkbox.checked) {
            batchSelectedJobs.add(jobId);
        } else {
            batchSelectedJobs.delete(jobId);
        }
        updateBatchSelectionUI();
    }

    function updateBatchSelectionUI() {
        const count = batchSelectedJobs.size;
        document.getElementById('batch-selection-count').textContent = count;

        // Enable/disable buttons based on selection
        const hasSelection = count > 0;
        document.getElementById('batch-process-btn').disabled = !hasSelection;
        document.getElementById('batch-mark-applied-btn').disabled = !hasSelection;
        document.getElementById('batch-mark-ready-btn').disabled = !hasSelection;
        document.getElementById('batch-discard-btn').disabled = !hasSelection;
        document.getElementById('batch-delete-btn').disabled = !hasSelection;

        // Update select-all checkbox state
        const allCheckboxes = document.querySelectorAll('.batch-row-checkbox');
        const selectAll = document.getElementById('batch-select-all');
        if (allCheckboxes.length === 0) {
            selectAll.checked = false;
            selectAll.indeterminate = false;
        } else if (count === 0) {
            selectAll.checked = false;
            selectAll.indeterminate = false;
        } else if (count === allCheckboxes.length) {
            selectAll.checked = true;
            selectAll.indeterminate = false;
        } else {
            selectAll.checked = false;
            selectAll.indeterminate = true;
        }

        // Update floating action bar visibility
        updateFloatingActionBar();
    }

    // ============================================================================
    // Floating Action Bar
    // ============================================================================

    function updateFloatingActionBar() {
        const floatingBar = document.getElementById('floating-action-bar');
        const floatingCount = document.getElementById('floating-selection-count');
        const count = batchSelectedJobs.size;

        if (count > 0) {
            floatingBar.classList.remove('hidden');
            floatingCount.textContent = count;
        } else {
            floatingBar.classList.add('hidden');
        }
    }

    // ============================================================================
    // Auto-Run Pipeline for Recently Added Jobs
    // ============================================================================

    // Track jobs we've already auto-run to avoid duplicate runs on page refresh
    const autoRunProcessedJobs = new Set();

    /**
     * Detects jobs added within the last 30 seconds and auto-runs all-ops on them.
     * This provides full visibility via progress panels and log pollers.
     */
    async function autoRunRecentlyAddedJobs() {
        const now = new Date();
        const threshold = 30 * 1000; // 30 seconds

        // Find all rows with batch_added_at attribute
        const rows = document.querySelectorAll('[data-batch-added-at]');
        const recentJobIds = [];

        rows.forEach(row => {
            const batchAddedAt = row.dataset.batchAddedAt;
            const jobId = row.dataset.jobId;

            if (!batchAddedAt || !jobId) return;
            if (autoRunProcessedJobs.has(jobId)) return; // Already processed

            try {
                const addedTime = new Date(batchAddedAt);
                const timeSinceAdded = now - addedTime;

                if (timeSinceAdded <= threshold) {
                    recentJobIds.push(jobId);
                    autoRunProcessedJobs.add(jobId); // Mark as processed
                }
            } catch (e) {
                BatchDebug.error('AUTO-RUN', `Failed to parse batch_added_at for ${jobId}:`, e);
            }
        });

        if (recentJobIds.length === 0) {
            BatchDebug.log('AUTO-RUN', 'No recently added jobs to auto-run');
            return;
        }

        BatchDebug.log('AUTO-RUN', `Found ${recentJobIds.length} recently added jobs`, recentJobIds);

        // Auto-select the jobs
        recentJobIds.forEach(jobId => {
            batchSelectedJobs.add(jobId);
            const checkbox = document.querySelector(`.batch-row-checkbox[data-job-id="${jobId}"]`);
            if (checkbox) checkbox.checked = true;
        });
        updateBatchSelectionUI();

        // Auto-run full-analysis with balanced tier (no confirmation dialog)
        const tier = 'balanced'; // Using new tier naming
        const tierDisplay = tierLabels[tier] || 'Balanced';

        showToast(`Auto-running Full Analysis on ${recentJobIds.length} newly added job(s) [${tierDisplay}]...`, 'info');

        // Initialize progress tracking
        initBatchProgress(recentJobIds, 'Full Analysis (Auto)');

        try {
            const response = await fetch('/api/runner/jobs/all-ops/batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    job_ids: recentJobIds,
                    tier: tier,
                    use_llm: true,
                    force_refresh: false
                })
            });

            const result = await response.json();
            BatchDebug.log('AUTO-RUN', 'Bulk endpoint response', result);

            if (response.ok && result.runs) {
                showToast(`Queued ${result.total_count} jobs for pipeline. Progress panels active.`, 'success');

                // Delegate to CLI panel for log streaming (no duplicate LogPollers)
                result.runs.forEach((run, index) => {
                    BatchDebug.log('AUTO-RUN', `Job ${run.job_id} queued with run_id ${run.run_id}`);

                    // Store runId and operation in job status for cli:complete event matching
                    const jobStatus = batchOperationState.jobStatuses.get(run.job_id);
                    if (jobStatus) {
                        jobStatus.runId = run.run_id;
                        jobStatus.status = 'queued';
                        jobStatus.operation = 'all-ops';  // Store operation for badge updates
                    }
                    renderProgressDetails();

                    // Dispatch event for live status badges
                    const position = run.position || (index + 1);
                    window.dispatchEvent(new CustomEvent('queue:job-status-changed', {
                        detail: {
                            jobId: run.job_id,
                            status: 'pending',
                            runId: run.run_id,
                            operation: 'all-ops',
                            position: position
                        }
                    }));

                    // Delegate to CLI panel for log streaming
                    if (run.run_id) {
                        const jobTitle = jobStatus?.title || `Job ${run.job_id.slice(-6)}`;
                        BatchDebug.log('AUTO-RUN', `Delegating to CLI panel for ${run.job_id}: ${run.run_id}`);
                        connectBatchLogPoller(run.run_id, run.job_id, 'all-ops', jobTitle);
                    }
                });

                startBatchProgressPolling();
            } else {
                BatchDebug.error('AUTO-RUN', 'Bulk endpoint failed', result);
                showToast(result.error || result.detail || 'Failed to auto-start pipeline', 'error');
                hideBatchProgress();
            }
        } catch (err) {
            BatchDebug.error('AUTO-RUN', 'Auto-run failed', err);
            showToast('Auto-run failed: ' + err.message, 'error');
            hideBatchProgress();
        }
    }

    // ============================================================================
    // Keyboard Shortcuts
    // ============================================================================

    function setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Skip if user is typing in an input field
            const activeElement = document.activeElement;
            const isInputFocused = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.tagName === 'SELECT' ||
                activeElement.isContentEditable
            );

            // Ctrl+A: Select all jobs
            if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                selectAllBatch();
                return;
            }

            // Ctrl+Enter: Execute full-analysis on selected
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                if (batchSelectedJobs.size > 0) {
                    executeBatchOperation('full-analysis');
                }
                return;
            }

            // Escape: Clear selection or close modals
            if (e.key === 'Escape') {
                // First try to close any open modals
                const deleteModal = document.getElementById('batch-delete-modal');
                const shortcutsModal = document.getElementById('keyboard-shortcuts-modal');

                if (!deleteModal.classList.contains('hidden')) {
                    closeBatchDeleteModal();
                    return;
                }
                if (!shortcutsModal.classList.contains('hidden')) {
                    closeKeyboardShortcutsHelp();
                    return;
                }

                // Otherwise clear selection
                clearBatchSelection();
                return;
            }

            // Skip single-key shortcuts if input is focused
            if (isInputFocused) return;

            // 'd': Mark selected as discarded
            if (e.key === 'd' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                if (batchSelectedJobs.size > 0) {
                    batchUpdateStatus('discarded');
                }
                return;
            }

            // 'a' (without Ctrl): Mark selected as applied
            if (e.key === 'a' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                if (batchSelectedJobs.size > 0) {
                    batchUpdateStatus('applied');
                }
                return;
            }
        });
    }

    function selectAllBatch() {
        const rows = document.querySelectorAll('.batch-row-checkbox');
        rows.forEach(row => {
            row.checked = true;
            batchSelectedJobs.add(row.dataset.jobId);
        });
        document.getElementById('batch-select-all').checked = true;
        updateBatchSelectionUI();
        showToast(`Selected ${rows.length} jobs`, 'info');
    }

    function clearBatchSelection() {
        const rows = document.querySelectorAll('.batch-row-checkbox');
        rows.forEach(row => {
            row.checked = false;
        });
        batchSelectedJobs.clear();
        document.getElementById('batch-select-all').checked = false;
        document.getElementById('batch-select-all').indeterminate = false;
        updateBatchSelectionUI();
    }

    // ============================================================================
    // Keyboard Shortcuts Help Modal
    // ============================================================================

    function toggleKeyboardShortcutsHelp() {
        const modal = document.getElementById('keyboard-shortcuts-modal');
        if (modal.classList.contains('hidden')) {
            modal.classList.remove('hidden');
        } else {
            modal.classList.add('hidden');
        }
    }

    function closeKeyboardShortcutsHelp() {
        document.getElementById('keyboard-shortcuts-modal').classList.add('hidden');
    }

    // ============================================================================
    // Tier Selection
    // ============================================================================

    function setBatchTier(tier) {
        // Normalize legacy tier codes to new format
        const normalizedTier = normalizeTierCode(tier);
        document.getElementById('batch-tier').value = normalizedTier;
        document.getElementById('batch-tier-label').textContent = tierLabels[normalizedTier] || normalizedTier;
        document.getElementById('batch-tier-icon').textContent = tierIcons[normalizedTier] || '\u2696\uFE0F';

        // Update selected state in dropdown
        document.querySelectorAll('[data-tier]').forEach(btn => {
            if (btn.dataset.tier === normalizedTier) {
                btn.classList.add('bg-indigo-50', 'dark:bg-indigo-900/20');
            } else {
                btn.classList.remove('bg-indigo-50', 'dark:bg-indigo-900/20');
            }
        });
    }

    /**
     * Normalize legacy tier codes (A/B/C/D, auto) to new format (fast/balanced/quality)
     */
    function normalizeTierCode(tier) {
        const legacyMapping = {
            'auto': 'balanced',
            'A': 'quality',
            'B': 'balanced',
            'C': 'fast',
            'D': 'fast',
            'Gold': 'quality',
            'Silver': 'balanced',
            'Bronze': 'fast'
        };
        return legacyMapping[tier] || tier;
    }

    /**
     * Get the backend operation name for an operation
     * Maps new frontend operation names to backend endpoint names
     */
    function getBackendOperationName(operation) {
        return operationAliases[operation] || operation;
    }

    // ============================================================================
    // Pipeline Operations
    // ============================================================================

    async function executeBatchOperation(operation) {
        if (batchSelectedJobs.size === 0) return;

        // Get tier and normalize it
        const rawTier = document.getElementById('batch-tier').value || 'balanced';
        const tier = normalizeTierCode(rawTier);
        const tierDisplay = tierLabels[tier] || tier;
        const count = batchSelectedJobs.size;
        const jobIds = Array.from(batchSelectedJobs);

        // Get backend operation name
        const backendOp = getBackendOperationName(operation);

        BatchDebug.log('BATCH', `Starting ${operation} (backend: ${backendOp})`, { count, tier, jobIds });

        // Map operations to their batch endpoints (using new /batch naming)
        // NOTE: /bulk endpoints are deprecated in favor of /batch
        const bulkEndpoints = {
            // New operation names (map to existing backend endpoints)
            'full-analysis': '/api/runner/jobs/all-ops/batch',
            'analyze-job': '/api/runner/jobs/full-extraction/batch',
            'prepare-annotations': '/api/runner/jobs/full-extraction/batch',  // Uses same endpoint for now
            'discover-contacts': '/api/runner/jobs/research-company/batch',   // Maps to research-company
            'generate-cover-letter': '/api/runner/jobs/generate-cv/batch',    // Maps to generate-cv
            'generate-outreach': '/api/runner/jobs/research-company/batch',   // Maps to research-company
            // Existing backend operations
            'full-extraction': '/api/runner/jobs/full-extraction/batch',
            'process-jd': '/api/runner/jobs/full-extraction/batch',
            'research-company': '/api/runner/jobs/research-company/batch',
            'generate-cv': '/api/runner/jobs/generate-cv/batch',
            'all-ops': '/api/runner/jobs/all-ops/batch',
            'structure-jd': '/api/runner/jobs/full-extraction/batch'
        };

        // Initialize progress tracking
        initBatchProgress(jobIds, operationNames[operation] || operation);

        try {
            showToast(`Starting ${operationNames[operation]} for ${count} jobs...`, 'info');

            // Use the appropriate bulk endpoint for the operation
            const endpoint = bulkEndpoints[operation];
            if (!endpoint) {
                BatchDebug.error('BATCH', `Unknown operation: ${operation}`);
                showToast(`Unknown operation: ${operation}`, 'error');
                hideBatchProgress();
                return;
            }

            BatchDebug.log('BATCH', `Calling bulk endpoint`, { endpoint });

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    job_ids: jobIds,
                    tier: tier,
                    use_llm: true,  // For full-extraction
                    force_refresh: false  // For research-company
                })
            });

            const result = await response.json();
            BatchDebug.log('BATCH', 'Bulk endpoint response', result);

            if (response.ok && result.runs) {
                // Success - jobs are queued
                showToast(`Queued ${result.total_count} jobs for ${operationNames[operation]}. Check Pipeline Queue for progress.`, 'success');

                // Mark all jobs as queued in progress panel and delegate to CLI panel for log streaming
                result.runs.forEach((run, index) => {
                    BatchDebug.log('PROGRESS', `Job ${run.job_id} queued with run_id ${run.run_id}`);

                    // Store runId and operation in job status so we can match cli:complete events later
                    const jobStatus = batchOperationState.jobStatuses.get(run.job_id);
                    if (jobStatus) {
                        jobStatus.runId = run.run_id;
                        jobStatus.status = 'queued';
                        jobStatus.operation = operation;  // Store operation for badge updates
                    }
                    renderProgressDetails();

                    // Immediately dispatch event so live status badges update
                    // Show 'pending' status first with queue position for better UX
                    // Then queue store events will update to 'running' when job actually starts
                    // Note: Must use window (not document) since live-status-badge.js listens on window
                    const position = run.position || (index + 1);  // Use position from response or calculate from index
                    window.dispatchEvent(new CustomEvent('queue:job-status-changed', {
                        detail: {
                            jobId: run.job_id,
                            status: 'pending',  // Changed from 'running' to show accurate queue state
                            runId: run.run_id,
                            operation: operation,
                            position: position
                        }
                    }));
                    BatchDebug.log('QUEUE', `Dispatched queue:job-status-changed for ${run.job_id} (position #${position})`);

                    // Delegate to CLI panel for log streaming - CLI panel will create the LogPoller
                    // and handle all log polling. This avoids dual-poller conflicts.
                    if (run.run_id) {
                        const jobTitle = jobStatus?.title || `Job ${run.job_id.slice(-6)}`;
                        BatchDebug.log('POLLER', `Delegating to CLI panel for job ${run.job_id}: ${run.run_id}`);
                        connectBatchLogPoller(run.run_id, run.job_id, operation, jobTitle);
                    }
                });

                // Start polling for status updates via WebSocket queue
                startBatchProgressPolling();
            } else {
                BatchDebug.error('BATCH', 'Bulk endpoint failed', result);
                showToast(result.error || result.detail || 'Failed to start batch', 'error');
                hideBatchProgress();
            }
        } catch (err) {
            BatchDebug.error('BATCH', 'Batch operation failed', err);
            showToast('Batch operation failed: ' + err.message, 'error');
            hideBatchProgress();
        }
    }

    // ============================================================================
    // Progress Panel Management
    // ============================================================================

    function initBatchProgress(jobIds, operationName) {
        batchOperationState.active = true;
        batchOperationState.totalJobs = jobIds.length;
        batchOperationState.completedJobs = 0;
        batchOperationState.cancelled = false;
        batchOperationState.jobStatuses.clear();

        // Get job titles from the table
        jobIds.forEach(jobId => {
            const row = document.querySelector(`[data-job-id="${jobId}"]`);
            const titleEl = row ? row.closest('tr')?.querySelector('.job-title-link') : null;
            const title = titleEl ? titleEl.textContent.trim() : `Job ${jobId.slice(-6)}`;
            batchOperationState.jobStatuses.set(jobId, { status: 'pending', title });
        });

        // Show progress panel
        const panel = document.getElementById('batch-progress-panel');
        panel.classList.remove('hidden');

        updateBatchProgressUI();
        renderProgressDetails();
    }

    function updateBatchProgressUI() {
        const { totalJobs, completedJobs } = batchOperationState;
        const percentage = totalJobs > 0 ? Math.round((completedJobs / totalJobs) * 100) : 0;

        document.getElementById('batch-progress-completed').textContent = completedJobs;
        document.getElementById('batch-progress-total').textContent = totalJobs;
        document.getElementById('batch-progress-bar').style.width = `${percentage}%`;
    }

    function updateJobProgress(jobId, status) {
        const job = batchOperationState.jobStatuses.get(jobId);
        if (job) {
            job.status = status;
            renderProgressDetails();
        }
    }

    // Progress display constants (moved outside function to avoid allocation per iteration)
    const PROGRESS_STATUS_ICONS = {
        pending: '<span class="text-gray-400"></span>',
        queued: '<span class="text-yellow-500"></span>',
        running: '<span class="text-blue-500 animate-pulse"></span>',
        success: '<span class="text-green-500"></span>',
        extracted: '<span class="text-green-600"></span>',
        error: '<span class="text-red-500"></span>'
    };

    const PROGRESS_STATUS_CLASSES = {
        pending: 'text-gray-500',
        queued: 'text-yellow-600',
        running: 'text-blue-600 font-medium',
        success: 'text-green-600',
        extracted: 'text-green-700 font-medium',
        error: 'text-red-600'
    };

    // Track pending render to avoid duplicate RAF calls
    let _progressRenderPending = false;

    function renderProgressDetails() {
        // Debounce: skip if render already scheduled
        if (_progressRenderPending) return;
        _progressRenderPending = true;

        // Use requestAnimationFrame to yield to browser and avoid blocking UI
        requestAnimationFrame(() => {
            _progressRenderPending = false;

            const container = document.getElementById('batch-progress-details');
            const items = [];

            batchOperationState.jobStatuses.forEach((job, jobId) => {
                items.push(`
                    <div class="flex items-center gap-2 text-xs ${PROGRESS_STATUS_CLASSES[job.status]}">
                        ${PROGRESS_STATUS_ICONS[job.status]}
                        <span class="truncate">${job.title}</span>
                    </div>
                `);
            });

            container.innerHTML = items.join('');
        });
    }

    function hideBatchProgress() {
        BatchDebug.log('PROGRESS', 'Hiding progress panel');
        batchOperationState.active = false;
        document.getElementById('batch-progress-panel').classList.add('hidden');
        // Clean up SSE connection
        closeBatchSSE();
    }

    function cancelBatchOperation() {
        BatchDebug.log('BATCH', 'Operation cancelled by user');
        batchOperationState.cancelled = true;
        showToast('Batch operation cancelled', 'warning');
        hideBatchProgress();
    }

    function completeBatchOperation() {
        BatchDebug.log('BATCH', 'Operation complete');
        // Keep the panel visible for a moment to show completion
        const { totalJobs, completedJobs, jobStatuses } = batchOperationState;
        const successCount = Array.from(jobStatuses.values()).filter(j => j.status === 'success').length;
        const errorCount = Array.from(jobStatuses.values()).filter(j => j.status === 'error').length;

        // Update panel to show completion state
        const panel = document.getElementById('batch-progress-panel');
        const spinnerIcon = panel.querySelector('.animate-spin');
        if (spinnerIcon) {
            spinnerIcon.classList.remove('animate-spin');
            if (errorCount === 0) {
                spinnerIcon.innerHTML = '<path fill="currentColor" d="M5 13l4 4L19 7"/>';
                spinnerIcon.classList.remove('text-indigo-500');
                spinnerIcon.classList.add('text-green-500');
            } else {
                spinnerIcon.classList.remove('text-indigo-500');
                spinnerIcon.classList.add('text-orange-500');
            }
        }

        // Auto-hide after delay and refresh table
        setTimeout(() => {
            hideBatchProgress();
            // Refresh the table to show updated states
            htmx.trigger('#batch-table-container', 'refresh');
        }, 2000);
    }

    // Polling for bulk operations (when using the bulk runner endpoint)
    let batchProgressPollInterval = null;

    function startBatchProgressPolling() {
        BatchDebug.log('PROGRESS', 'Starting progress polling (every 2s)');

        // Poll every 2 seconds to check status
        batchProgressPollInterval = setInterval(async () => {
            if (!batchOperationState.active) {
                BatchDebug.log('PROGRESS', 'Stopping polling - batch no longer active');
                clearInterval(batchProgressPollInterval);
                return;
            }

            // Check status of each job via the queue store
            const queueStore = window.Alpine?.store('queue');
            if (queueStore) {
                let runningCount = 0;
                let completeCount = 0;

                // Build lookup sets for O(1) checks
                const runningIds = new Set(queueStore.running.map(i => i.job_id));
                const pendingIds = new Set(queueStore.pending.map(i => i.job_id));
                const failedIds = new Set(queueStore.failed.map(i => i.job_id));
                const historyIds = new Set(queueStore.history.map(i => i.job_id));

                batchOperationState.jobStatuses.forEach((job, jobId) => {
                    if (runningIds.has(jobId)) {
                        job.status = 'running';
                        runningCount++;
                    } else if (historyIds.has(jobId)) {
                        // In history = completed successfully
                        job.status = 'success';
                        completeCount++;
                    } else if (failedIds.has(jobId)) {
                        job.status = 'error';
                        completeCount++;
                    } else if (pendingIds.has(jobId)) {
                        job.status = 'queued';
                    }
                    // If not found anywhere, keep current status (might still be initializing)
                });

                BatchDebug.log('PROGRESS', `Poll update: ${completeCount}/${batchOperationState.totalJobs} complete, ${runningCount} running`);

                batchOperationState.completedJobs = completeCount;
                updateBatchProgressUI();
                renderProgressDetails();

                // Check if all done
                if (completeCount >= batchOperationState.totalJobs) {
                    BatchDebug.log('PROGRESS', 'All jobs complete - stopping polling');
                    clearInterval(batchProgressPollInterval);
                    completeBatchOperation();
                }
            } else {
                BatchDebug.warn('PROGRESS', 'Queue store not available for polling');
            }
        }, 2000);
    }

    // ============================================================================
    // Status Updates
    // ============================================================================

    async function batchUpdateStatus(newStatus) {
        if (batchSelectedJobs.size === 0) return;

        const count = batchSelectedJobs.size;

        try {
            const response = await fetch('/api/jobs/status/bulk', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    job_ids: Array.from(batchSelectedJobs),
                    status: newStatus
                })
            });

            const result = await response.json();
            if (result.success || response.ok) {
                showToast(`Updated ${result.updated_count || count} jobs to "${newStatus}"`, 'success');
                // Clear selection and refresh table
                batchSelectedJobs.clear();
                updateBatchSelectionUI();
                htmx.trigger('#batch-table-container', 'refresh');
            } else {
                showToast(result.error || 'Failed to update status', 'error');
            }
        } catch (err) {
            showToast('Status update failed: ' + err.message, 'error');
        }
    }

    async function updateBatchJobStatus(jobId, newStatus) {
        // DEBUG: Log all status change attempts to help trace the bug
        const selectEl = document.getElementById(`status-select-${jobId}`);
        const previousStatus = selectEl?.dataset.currentStatus || 'unknown';
        console.log(`[STATUS-DEBUG] updateBatchJobStatus called: jobId=${jobId}, newStatus=${newStatus}, previousStatus=${previousStatus}`);

        // Safety check: if the newStatus is the same as the data attribute, skip the update
        // This prevents HTMX swap race conditions from triggering duplicate/erroneous updates
        if (selectEl && selectEl.dataset.currentStatus === newStatus) {
            console.log(`[STATUS-DEBUG] Skipping - status unchanged: ${newStatus}`);
            return;
        }

        // Safety check: warn if job is currently in an active operation
        const queueStore = window.Alpine?.store('queue');
        if (queueStore) {
            const isRunning = queueStore.running?.some(j => j.job_id === jobId);
            const isPending = queueStore.pending?.some(j => j.job_id === jobId);
            if (isRunning || isPending) {
                console.warn(`[STATUS-DEBUG] Warning: Status change while job is in queue (running=${isRunning}, pending=${isPending})`);
            }
        }

        try {
            const response = await fetch('/api/jobs/status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ job_id: jobId, status: newStatus })
            });

            if (response.ok) {
                // Update the data attribute to reflect the new status
                if (selectEl) {
                    selectEl.dataset.currentStatus = newStatus;
                }

                // If job is no longer "under processing", remove from view after a brief delay
                if (newStatus !== 'under processing') {
                    setTimeout(() => {
                        htmx.trigger('#batch-table-container', 'refresh');
                    }, 500);
                }
            } else {
                showToast('Failed to update status', 'error');
                // Revert the dropdown to the previous value on failure
                if (selectEl) {
                    selectEl.value = previousStatus;
                }
            }
        } catch (err) {
            showToast('Status update failed: ' + err.message, 'error');
            // Revert the dropdown to the previous value on failure
            if (selectEl) {
                selectEl.value = previousStatus;
            }
        }
    }

    // ============================================================================
    // Delete Operations
    // ============================================================================

    function openBatchDeleteModal() {
        document.getElementById('delete-count').textContent = batchSelectedJobs.size;
        document.getElementById('batch-delete-modal').classList.remove('hidden');
    }

    function closeBatchDeleteModal() {
        document.getElementById('batch-delete-modal').classList.add('hidden');
    }

    async function confirmBatchDelete() {
        if (batchSelectedJobs.size === 0) return;

        try {
            const response = await fetch('/api/jobs/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ job_ids: Array.from(batchSelectedJobs) })
            });

            const result = await response.json();
            if (result.success || response.ok) {
                showToast(`Deleted ${result.deleted_count || batchSelectedJobs.size} jobs`, 'success');
                batchSelectedJobs.clear();
                updateBatchSelectionUI();
                closeBatchDeleteModal();
                htmx.trigger('#batch-table-container', 'refresh');
            } else {
                showToast(result.error || 'Failed to delete jobs', 'error');
            }
        } catch (err) {
            showToast('Delete failed: ' + err.message, 'error');
        }
    }

    // ============================================================================
    // Navigation & UI
    // ============================================================================

    function navigateToBatchJob(event, jobId) {
        // Don't navigate if clicking on interactive elements
        if (event.target.closest('input, select, button, a, .no-navigate')) {
            return;
        }
        window.location.href = `/job/${jobId}`;
    }

    // Update job count after HTMX load
    document.body.addEventListener('htmx:afterSwap', function(event) {
        if (event.detail.target.id === 'batch-table-container') {
            const rows = document.querySelectorAll('.batch-row-checkbox');
            document.getElementById('batch-job-count').innerHTML =
                `<span class="font-semibold">${rows.length}</span> jobs in queue`;

            // Restore selection state after refresh
            rows.forEach(checkbox => {
                if (batchSelectedJobs.has(checkbox.dataset.jobId)) {
                    checkbox.checked = true;
                }
            });
            updateBatchSelectionUI();

            // Restore expanded rows state after HTMX swap
            // Use setTimeout to ensure Alpine.js has initialized the new rows
            setTimeout(restoreExpandedRows, 50);

            // Auto-run pipeline for jobs that were just moved to batch
            // Runs after a short delay to let the UI settle
            setTimeout(autoRunRecentlyAddedJobs, 100);
        }
    });

    // Clear selection on page load and initialize keyboard shortcuts
    document.addEventListener('DOMContentLoaded', function() {
        batchSelectedJobs.clear();
        updateBatchSelectionUI();
        setupKeyboardShortcuts();

        // Listen for annotation updates to turn JD badge green immediately
        window.addEventListener('annotations:updated', function(e) {
            const { jobId, hasAnnotations } = e.detail;
            const badge = document.querySelector(`[data-jd-badge="${jobId}"]`);
            if (badge) {
                // Remove all state classes
                badge.classList.remove(
                    'bg-gray-100', 'text-gray-400', 'dark:bg-gray-700', 'dark:text-gray-500',
                    'bg-orange-100', 'text-orange-600', 'dark:bg-orange-900/50', 'dark:text-orange-300',
                    'bg-green-100', 'text-green-700', 'dark:bg-green-900', 'dark:text-green-300'
                );

                // Add green classes if has annotations, orange otherwise (already extracted since modal is open)
                if (hasAnnotations) {
                    badge.classList.add('bg-green-100', 'text-green-700', 'dark:bg-green-900', 'dark:text-green-300', 'cursor-pointer');
                    badge.title = 'JD: Annotated';
                } else {
                    badge.classList.add('bg-orange-100', 'text-orange-600', 'dark:bg-orange-900/50', 'dark:text-orange-300', 'cursor-pointer');
                    badge.title = 'JD: Extracted';
                }
                BatchDebug.log('BADGE', `Updated JD badge for ${jobId}:`, hasAnnotations ? 'green' : 'orange');
            }
        });

        // Listen for research updates to turn RS badge orange/green immediately
        window.addEventListener('research:updated', function(e) {
            const { jobId, hasResearch, hasContacts } = e.detail;
            const badge = document.querySelector(`[data-rs-badge="${jobId}"]`);
            if (badge) {
                // Remove all state classes
                badge.classList.remove(
                    'bg-gray-100', 'text-gray-400', 'dark:bg-gray-700', 'dark:text-gray-500',
                    'bg-orange-100', 'text-orange-600', 'dark:bg-orange-900/50', 'dark:text-orange-300',
                    'bg-green-100', 'text-green-700', 'dark:bg-green-900', 'dark:text-green-300',
                    'cursor-pointer', 'hover:bg-green-200', 'dark:hover:bg-green-800',
                    'hover:bg-orange-200', 'dark:hover:bg-orange-800'
                );

                if (hasContacts) {
                    badge.classList.add('bg-green-100', 'text-green-700', 'dark:bg-green-900', 'dark:text-green-300', 'cursor-pointer', 'hover:bg-green-200', 'dark:hover:bg-green-800');
                    badge.title = 'Research: Has contacts';
                    badge.onclick = () => openBatchContactsSidebar(jobId);
                } else if (hasResearch) {
                    badge.classList.add('bg-orange-100', 'text-orange-600', 'dark:bg-orange-900/50', 'dark:text-orange-300', 'cursor-pointer', 'hover:bg-orange-200', 'dark:hover:bg-orange-800');
                    badge.title = 'Research: Researched';
                    badge.onclick = () => openBatchContactsSidebar(jobId);
                }
                BatchDebug.log('BADGE', `Updated RS badge for ${jobId}:`, hasContacts ? 'green' : (hasResearch ? 'orange' : 'gray'));
            }
        });

        // Listen for CV generation to turn CV badge orange immediately
        window.addEventListener('cv:generated', function(e) {
            const { jobId, hasCV, isEdited } = e.detail;
            const badge = document.querySelector(`[data-cv-badge="${jobId}"]`);
            if (badge) {
                // Remove all state classes
                badge.classList.remove(
                    'bg-gray-100', 'text-gray-400', 'dark:bg-gray-700', 'dark:text-gray-500',
                    'bg-orange-100', 'text-orange-600', 'dark:bg-orange-900/50', 'dark:text-orange-300',
                    'bg-green-100', 'text-green-700', 'dark:bg-green-900', 'dark:text-green-300',
                    'cursor-pointer', 'hover:bg-green-200', 'dark:hover:bg-green-800',
                    'hover:bg-orange-200', 'dark:hover:bg-orange-800'
                );

                if (isEdited) {
                    badge.classList.add('bg-green-100', 'text-green-700', 'dark:bg-green-900', 'dark:text-green-300', 'cursor-pointer', 'hover:bg-green-200', 'dark:hover:bg-green-800');
                    badge.title = 'CV: Edited';
                    badge.onclick = () => openBatchCVEditor(jobId);
                } else if (hasCV) {
                    badge.classList.add('bg-orange-100', 'text-orange-600', 'dark:bg-orange-900/50', 'dark:text-orange-300', 'cursor-pointer', 'hover:bg-orange-200', 'dark:hover:bg-orange-800');
                    badge.title = 'CV: Generated';
                    badge.onclick = () => openBatchCVEditor(jobId);
                }
                BatchDebug.log('BADGE', `Updated CV badge for ${jobId}:`, isEdited ? 'green' : (hasCV ? 'orange' : 'gray'));
            }
        });

        // Listen for queue events to track actual extraction completion
        // Note: Events are dispatched on window, so listen on window
        window.addEventListener('queue:job-started', function(e) {
            const jobId = e.detail?.jobId;
            if (jobId && batchOperationState.jobStatuses.has(jobId)) {
                updateJobProgress(jobId, 'running');
            }
        });

        window.addEventListener('queue:job-completed', function(e) {
            const jobId = e.detail?.jobId;
            if (jobId && batchOperationState.jobStatuses.has(jobId)) {
                updateJobProgress(jobId, 'extracted');
                batchOperationState.completedJobs++;
                updateBatchProgressUI();

                // Check if all batch jobs are done
                const allDone = Array.from(batchOperationState.jobStatuses.values())
                    .every(j => j.status === 'extracted' || j.status === 'error' || j.status === 'success');
                if (allDone && batchOperationState.active) {
                    const extractedCount = Array.from(batchOperationState.jobStatuses.values())
                        .filter(j => j.status === 'extracted' || j.status === 'success').length;
                    const totalCount = batchOperationState.jobStatuses.size;
                    showToast(`Extracted ${extractedCount}/${totalCount} jobs`, extractedCount === totalCount ? 'success' : 'warning');
                    completeBatchOperation();
                    // Refresh the table to show updated progress indicators
                    htmx.trigger(document.body, 'refresh');
                }
            }
        });

        window.addEventListener('queue:job-failed', function(e) {
            const jobId = e.detail?.jobId;
            if (jobId && batchOperationState.jobStatuses.has(jobId)) {
                updateJobProgress(jobId, 'error');
                batchOperationState.completedJobs++;
                updateBatchProgressUI();
            }
        });

        // Listen for CLI panel completion events (from LogPoller in cli-panel.js)
        // This is the primary way batch page tracks job completion since we delegate
        // log polling to the CLI panel
        window.addEventListener('cli:complete', function(e) {
            const { runId, status, error } = e.detail || {};
            BatchDebug.log('CLI-EVENT', `Received cli:complete for ${runId}`, { status, error });

            // Find the job ID for this run - we need to look through our batch state
            // to match runId back to jobId
            let matchedJobId = null;
            for (const [jobId, jobState] of batchOperationState.jobStatuses.entries()) {
                // The batch operation stores runId in a Map keyed by jobId
                // We need to check if this completion event matches any of our tracked jobs
                if (jobState.runId === runId) {
                    matchedJobId = jobId;
                    break;
                }
            }

            // Also dispatch queue event for live status badges if we found the job
            if (matchedJobId) {
                const mappedStatus = status === 'success' ? 'success' : 'error';
                updateJobProgress(matchedJobId, mappedStatus);

                window.dispatchEvent(new CustomEvent('queue:job-status-changed', {
                    detail: {
                        jobId: matchedJobId,
                        status: mappedStatus,
                        operation: 'pipeline'
                    }
                }));

                // Dispatch badge update events based on operation type
                const jobState = batchOperationState.jobStatuses.get(matchedJobId);
                const operation = jobState?.operation;

                if (status === 'success' && operation) {
                    // Research operations update RS badge
                    if (operation === 'research-company' || operation === 'discover-contacts' || operation === 'all-ops') {
                        // For research completion, assume contacts were found (green) on success
                        // The actual state will be corrected on page refresh if different
                        window.dispatchEvent(new CustomEvent('research:updated', {
                            detail: {
                                jobId: matchedJobId,
                                hasResearch: true,
                                hasContacts: true  // Optimistic - assume contacts found on success
                            }
                        }));
                        BatchDebug.log('BADGE', `Dispatched research:updated for ${matchedJobId}`);
                    }

                    // CV generation updates CV badge
                    if (operation === 'generate-cv' || operation === 'generate-cover-letter' || operation === 'all-ops') {
                        window.dispatchEvent(new CustomEvent('cv:generated', {
                            detail: {
                                jobId: matchedJobId,
                                hasCV: true,
                                isEdited: false  // Newly generated, not edited yet
                            }
                        }));
                        BatchDebug.log('BADGE', `Dispatched cv:generated for ${matchedJobId}`);
                    }
                }
            }
        });
    });
</script>
{% endblock %}
