# AI Agent Fallback Infrastructure Implementation Plan

**Created**: 2025-11-29
**Status**: Planning
**Priority**: Medium
**Related Requirement**: #10 from missing.md
**Reference**: `plans/firecrawl-contact-discovery-solution.md` (Option B)

---

## Problem Statement

When FireCrawl contact discovery fails (rate limits, blocked sites, network errors), the pipeline has no fallback mechanism. This results in empty contact lists and incomplete outreach packages.

---

## Solution Overview

Implement **Option B** from `firecrawl-contact-discovery-solution.md`: an AI-powered fallback agent that uses LLM reasoning to generate synthetic contacts when FireCrawl fails.

### Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     LAYER 5: PEOPLE MAPPER                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  Step 1: Try FireCrawl (Option A)                        │   │
│  │  - Run SEO-style queries                                  │   │
│  │  - Extract contacts from search metadata                  │   │
│  └──────────────────────────────────────────────────────────┘   │
│                           ↓                                      │
│                    [Success?]                                    │
│                    /        \                                    │
│                  Yes         No                                  │
│                   ↓           ↓                                  │
│              [Return     ┌────────────────────────────────┐      │
│               Contacts]  │  Step 2: AI Agent Fallback     │      │
│                          │  (Option B)                     │      │
│                          │  - LLM generates synthetic     │      │
│                          │    role-based contacts         │      │
│                          │  - Uses company context for    │      │
│                          │    realistic targeting         │      │
│                          └────────────────────────────────┘      │
│                                     ↓                            │
│                              [Return Contacts]                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Configuration

### Environment Variables

```bash
# Enable AI fallback when FireCrawl fails (default: true)
ENABLE_FIRECRAWL_FALLBACK=true

# Maximum FireCrawl retries before fallback (default: 2)
FIRECRAWL_MAX_RETRIES=2

# AI model for fallback generation (default: gpt-4o-mini)
FALLBACK_LLM_MODEL=gpt-4o-mini
```

### Feature Flags

| Flag | Default | Description |
|------|---------|-------------|
| `ENABLE_FIRECRAWL_FALLBACK` | `true` | Enable AI agent fallback |
| `FIRECRAWL_MAX_RETRIES` | `2` | Retries before fallback |
| `FALLBACK_LLM_MODEL` | `gpt-4o-mini` | Model for synthetic contacts |

---

## Implementation

### Phase 1: Fallback Agent Class (3 hours)

**File**: `src/layer5/contact_fallback_agent.py`

```python
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import JsonOutputParser
from pydantic import BaseModel, Field
from typing import List, Optional

class SyntheticContact(BaseModel):
    """Synthetic contact generated by AI agent."""
    name: str = Field(description="Realistic full name")
    role: str = Field(description="Job title at the company")
    department: str = Field(description="Department (Engineering, HR, Recruiting, etc.)")
    contact_type: str = Field(description="primary or secondary")
    linkedin_url: Optional[str] = Field(default=None, description="Hypothetical LinkedIn URL pattern")
    rationale: str = Field(description="Why this contact is relevant")

class ContactFallbackAgent:
    """AI agent that generates synthetic contacts when FireCrawl fails."""

    SYSTEM_PROMPT = '''You are an expert recruiter who knows organizational structures.

Your task: Generate realistic contact targets for a job application when search engines fail.

IMPORTANT RULES:
1. Generate REALISTIC role titles (not generic like "Manager")
2. Use COMMON names appropriate for the company's location/industry
3. Always include recruiter + hiring manager roles
4. LinkedIn URLs should follow pattern: linkedin.com/in/firstname-lastname-randomchars
5. Mark contacts as "primary" (direct decision makers) or "secondary" (influencers)

OUTPUT FORMAT: JSON array of contacts with:
- name: Full name (realistic for industry)
- role: Specific job title
- department: Department name
- contact_type: "primary" or "secondary"
- linkedin_url: Hypothetical LinkedIn URL
- rationale: Why this person would be relevant
'''

    USER_PROMPT_TEMPLATE = '''Generate 8 realistic contacts for a {role_title} position at {company}.

CONTEXT:
- Company: {company}
- Industry: {industry}
- Role: {role_title}
- Department: {department}

Company Research:
{company_research}

Generate contacts in these categories:
1. Technical Recruiter (primary)
2. Talent Acquisition Partner (primary)
3. Hiring Manager / Engineering Director (primary)
4. Department VP / Head of {department} (primary)
5-8. Secondary contacts (team leads, HR partners, etc.)

Return JSON array of 8 contacts.
'''

    def __init__(self, model: str = "gpt-4o-mini"):
        self.llm = ChatOpenAI(model=model, temperature=0.7)
        self.parser = JsonOutputParser(pydantic_object=List[SyntheticContact])

    def generate_contacts(
        self,
        company: str,
        role_title: str,
        department: str,
        company_research: dict = None
    ) -> List[SyntheticContact]:
        """Generate synthetic contacts using AI reasoning."""

        # Extract industry from company research
        industry = "Technology"  # Default
        if company_research:
            industry = company_research.get("industry", industry)

        prompt = self.USER_PROMPT_TEMPLATE.format(
            company=company,
            industry=industry,
            role_title=role_title,
            department=department,
            company_research=str(company_research) if company_research else "Not available"
        )

        messages = [
            {"role": "system", "content": self.SYSTEM_PROMPT},
            {"role": "user", "content": prompt}
        ]

        response = self.llm.invoke(messages)
        contacts = self.parser.parse(response.content)

        return contacts
```

### Phase 2: Integration with People Mapper (2 hours)

**File**: `src/layer5/people_mapper.py`

```python
from src.layer5.contact_fallback_agent import ContactFallbackAgent
from src.common.config import Config

class PeopleMapper:
    def __init__(self):
        self.fallback_enabled = Config.get_bool("ENABLE_FIRECRAWL_FALLBACK", True)
        self.max_retries = Config.get_int("FIRECRAWL_MAX_RETRIES", 2)
        self.fallback_agent = ContactFallbackAgent() if self.fallback_enabled else None

    def discover_contacts(self, state: JobState) -> JobState:
        """Discover contacts with fallback to AI agent."""

        contacts = []
        firecrawl_failed = False

        # Try FireCrawl first
        if not state.get("disable_firecrawl"):
            for attempt in range(self.max_retries):
                try:
                    contacts = self._firecrawl_search(state)
                    if contacts:
                        break
                except FireCrawlError as e:
                    logger.warning(f"FireCrawl attempt {attempt + 1} failed: {e}")
                    if attempt == self.max_retries - 1:
                        firecrawl_failed = True

        # Fallback to AI agent if FireCrawl failed or returned no results
        if (firecrawl_failed or not contacts) and self.fallback_agent:
            logger.info("Falling back to AI agent for contact generation")
            contacts = self._generate_fallback_contacts(state)
            state["contact_source"] = "ai_fallback"
        else:
            state["contact_source"] = "firecrawl"

        state["discovered_contacts"] = contacts
        return state

    def _generate_fallback_contacts(self, state: JobState) -> List[dict]:
        """Generate synthetic contacts using AI fallback agent."""

        synthetic = self.fallback_agent.generate_contacts(
            company=state.get("company"),
            role_title=state.get("title"),
            department=self._infer_department(state.get("title")),
            company_research=state.get("company_research")
        )

        # Convert to standard contact format
        contacts = []
        for contact in synthetic:
            contacts.append({
                "name": contact.name,
                "role": contact.role,
                "linkedin_url": contact.linkedin_url,
                "source": "ai_synthetic",
                "confidence": 0.6,  # Lower confidence for synthetic
                "category": contact.contact_type
            })

        return contacts
```

### Phase 3: Monitoring & Metrics (1 hour)

Track fallback usage for optimization:

```python
# In StructuredLogger
def contact_discovery_result(self, source: str, count: int, firecrawl_attempts: int):
    """Log contact discovery outcome."""
    self.emit("contact_discovery", metadata={
        "source": source,  # "firecrawl" or "ai_fallback"
        "contact_count": count,
        "firecrawl_attempts": firecrawl_attempts
    })
```

---

## Files to Modify

| File | Changes |
|------|---------|
| `src/layer5/contact_fallback_agent.py` | New file - AI fallback agent |
| `src/layer5/people_mapper.py` | Add fallback integration |
| `src/common/config.py` | Add fallback config vars |
| `.env.example` | Add fallback env vars |

---

## Test Cases

1. **Fallback Triggered**: FireCrawl fails → AI generates contacts
2. **Fallback Disabled**: Config flag off → no fallback, empty contacts
3. **Contact Quality**: Synthetic contacts have realistic names/roles
4. **Retry Logic**: 2 FireCrawl retries before fallback
5. **Metrics**: Fallback usage logged correctly

---

## Success Criteria

- [ ] AI fallback generates 8 realistic contacts
- [ ] Contacts include recruiter + hiring manager roles
- [ ] Config flag `ENABLE_FIRECRAWL_FALLBACK` works
- [ ] Metrics track fallback vs FireCrawl usage
- [ ] Outreach packages complete even when FireCrawl fails

---

## Effort Estimate

**Total**: 8-12 hours

- Phase 1 (Fallback Agent): 3 hours
- Phase 2 (Integration): 2 hours
- Phase 3 (Monitoring): 1 hour
- Testing & Validation: 2-4 hours
- Documentation: 1 hour

---

## Cost Analysis

| Approach | FireCrawl Calls | LLM Calls | Est. Cost/Job |
|----------|-----------------|-----------|---------------|
| FireCrawl Only | 4-6 | 0 | ~$0.06 |
| FireCrawl + Fallback | 2-6 | 0-1 | ~$0.08 |
| Fallback Only (testing) | 0 | 1 | ~$0.02 |

Fallback adds minimal cost (~$0.02/job) when triggered.

---

## Future Enhancements

- LangGraph sub-agent with tool calling for more sophisticated search
- Caching of synthetic contacts per company
- Quality scoring of generated contacts
- A/B testing of outreach success rates (FireCrawl vs AI)
