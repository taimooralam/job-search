"""
CV Loader - Load pre-split role data from data/master-cv/

Reads the static role files and metadata created during setup.
The master CV is split ONCE into static files:
- data/master-cv/roles/*.md (one file per company/role)
- data/master-cv/role_metadata.json (structured metadata)

This approach:
1. Avoids re-parsing master CV on every run
2. Allows manual curation of role files
3. Makes it easy to add/remove bullets per role
4. Provides structured metadata for intelligent selection
"""

import json
from pathlib import Path
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field
from src.common.logger import get_logger


@dataclass
class RoleData:
    """Data for a single role/company from the master CV."""

    id: str
    company: str
    title: str
    location: str
    period: str
    start_year: int
    end_year: Optional[int]
    is_current: bool
    duration_years: int
    industry: str
    team_size: str
    primary_competencies: List[str]
    keywords: List[str]

    # Content loaded from role file
    achievements: List[str] = field(default_factory=list)
    hard_skills: List[str] = field(default_factory=list)
    soft_skills: List[str] = field(default_factory=list)
    raw_content: str = ""

    @property
    def bullet_count(self) -> int:
        """Return count of achievements (computed, not stored)."""
        return len(self.achievements)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for state/serialization."""
        return {
            "id": self.id,
            "company": self.company,
            "title": self.title,
            "location": self.location,
            "period": self.period,
            "start_year": self.start_year,
            "end_year": self.end_year,
            "is_current": self.is_current,
            "duration_years": self.duration_years,
            "industry": self.industry,
            "team_size": self.team_size,
            "bullet_count": self.bullet_count,  # Computed property
            "primary_competencies": self.primary_competencies,
            "keywords": self.keywords,
            "achievements": self.achievements,
            "hard_skills": self.hard_skills,
            "soft_skills": self.soft_skills,
        }


@dataclass
class CandidateData:
    """
    Candidate profile data from master CV metadata.

    NOTE: profile and core_skills are NOT stored here - they are
    dynamically generated by the Header Generator after stitching,
    tailored to the target role category and JD requirements.
    """

    name: str
    title_base: str  # Base title, will be tailored per application
    email: str
    phone: str
    linkedin: str
    location: str
    languages: List[str]
    education_masters: str
    education_bachelors: str
    certifications: List[str]
    years_experience: int

    # Roles loaded from individual files
    roles: List[RoleData] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for state/serialization."""
        return {
            "name": self.name,
            "title_base": self.title_base,
            "email": self.email,
            "phone": self.phone,
            "linkedin": self.linkedin,
            "location": self.location,
            "languages": self.languages,
            "education_masters": self.education_masters,
            "education_bachelors": self.education_bachelors,
            "certifications": self.certifications,
            "years_experience": self.years_experience,
            "roles": [r.to_dict() for r in self.roles],
        }


class CVLoader:
    """
    Load pre-split CV data from data/master-cv/.

    This class reads the static role files and metadata that were
    created during initial setup. No dynamic parsing needed.

    Usage:
        loader = CVLoader()
        candidate = loader.load()

        # Access all roles
        for role in candidate.roles:
            print(f"{role.company}: {len(role.achievements)} bullets")

        # Filter by competency
        leadership_roles = loader.filter_by_competency("leadership")
    """

    DEFAULT_DATA_PATH = Path("data/master-cv")

    def __init__(self, data_path: Optional[Path] = None):
        """
        Initialize the CV loader.

        Args:
            data_path: Path to master-cv data directory.
                       Defaults to data/master-cv/
        """
        self.data_path = data_path or self.DEFAULT_DATA_PATH
        self.metadata_path = self.data_path / "role_metadata.json"
        self.roles_path = self.data_path / "roles"
        self._candidate: Optional[CandidateData] = None
        self._logger = get_logger(__name__)

    def load(self) -> CandidateData:
        """
        Load all CV data from pre-split files.

        Returns:
            CandidateData with all roles populated

        Raises:
            FileNotFoundError: If metadata or role files missing
            ValueError: If metadata is malformed
        """
        if self._candidate is not None:
            return self._candidate

        # Load metadata
        if not self.metadata_path.exists():
            raise FileNotFoundError(
                f"Role metadata not found at {self.metadata_path}. "
                "Run the CV split setup first."
            )

        with open(self.metadata_path, "r") as f:
            metadata = json.load(f)

        # Build candidate data (static fields only - profile/skills generated later)
        candidate_meta = metadata["candidate"]
        self._candidate = CandidateData(
            name=candidate_meta["name"],
            title_base=candidate_meta["title_base"],
            email=candidate_meta["contact"]["email"],
            phone=candidate_meta["contact"]["phone"],
            linkedin=candidate_meta["contact"]["linkedin"],
            location=candidate_meta["contact"]["location"],
            languages=candidate_meta["languages"],
            education_masters=candidate_meta["education"]["masters"],
            education_bachelors=candidate_meta["education"]["bachelors"],
            certifications=candidate_meta["certifications"],
            years_experience=candidate_meta["years_experience"],
            roles=[],
        )

        # Load each role file
        for role_meta in metadata["roles"]:
            role = self._load_role(role_meta)
            self._candidate.roles.append(role)

        self._logger.info(f"Loaded {len(self._candidate.roles)} roles from master CV")
        return self._candidate

    def _load_role(self, role_meta: Dict[str, Any]) -> RoleData:
        """Load a single role from its markdown file."""
        role_file = self.data_path / role_meta["file"]

        if not role_file.exists():
            raise FileNotFoundError(f"Role file not found: {role_file}")

        with open(role_file, "r") as f:
            content = f.read()

        # Parse achievements and skills from content
        achievements = self._parse_achievements(content)
        hard_skills, soft_skills = self._parse_skills(content)

        return RoleData(
            id=role_meta["id"],
            company=role_meta["company"],
            title=role_meta["title"],
            location=role_meta["location"],
            period=role_meta["period"],
            start_year=role_meta["start_year"],
            end_year=role_meta["end_year"],
            is_current=role_meta["is_current"],
            duration_years=role_meta["duration_years"],
            industry=role_meta["industry"],
            team_size=role_meta["team_size"],
            primary_competencies=role_meta["primary_competencies"],
            keywords=role_meta["keywords"],
            achievements=achievements,
            hard_skills=hard_skills,
            soft_skills=soft_skills,
            raw_content=content,
        )

    def _parse_achievements(self, content: str) -> List[str]:
        """Parse achievement bullets from role file content."""
        achievements = []
        in_achievements = False

        for line in content.split("\n"):
            line = line.strip()

            if line == "## Achievements":
                in_achievements = True
                continue
            elif line.startswith("## "):
                in_achievements = False
                continue

            if in_achievements and line.startswith("â€¢"):
                # Remove bullet point and clean up
                achievement = line[1:].strip()
                if achievement:
                    achievements.append(achievement)

        return achievements

    def _parse_skills(self, content: str) -> tuple[List[str], List[str]]:
        """Parse hard and soft skills from role file content."""
        hard_skills = []
        soft_skills = []

        for line in content.split("\n"):
            line = line.strip()

            if line.startswith("**Hard Skills**:"):
                skills_str = line.replace("**Hard Skills**:", "").strip()
                hard_skills = [s.strip() for s in skills_str.split(",") if s.strip()]
            elif line.startswith("**Soft Skills**:"):
                skills_str = line.replace("**Soft Skills**:", "").strip()
                soft_skills = [s.strip() for s in skills_str.split(",") if s.strip()]

        return hard_skills, soft_skills

    def filter_by_competency(self, competency: str) -> List[RoleData]:
        """
        Get roles where the given competency is primary.

        Args:
            competency: One of "leadership", "architecture", "delivery", "process"

        Returns:
            List of roles with that competency as primary
        """
        if self._candidate is None:
            self.load()

        return [
            role for role in self._candidate.roles
            if competency in role.primary_competencies
        ]

    def filter_by_industry(self, industry: str) -> List[RoleData]:
        """Get roles in a specific industry."""
        if self._candidate is None:
            self.load()

        return [
            role for role in self._candidate.roles
            if industry.lower() in role.industry.lower()
        ]

    def get_current_role(self) -> Optional[RoleData]:
        """Get the current (most recent) role."""
        if self._candidate is None:
            self.load()

        for role in self._candidate.roles:
            if role.is_current:
                return role
        return None

    def get_all_keywords(self) -> List[str]:
        """Get deduplicated list of all keywords across roles."""
        if self._candidate is None:
            self.load()

        keywords = set()
        for role in self._candidate.roles:
            keywords.update(role.keywords)

        return sorted(keywords)

    def get_total_bullets(self) -> int:
        """Get total number of achievement bullets across all roles."""
        if self._candidate is None:
            self.load()

        return sum(len(role.achievements) for role in self._candidate.roles)
